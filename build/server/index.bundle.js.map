{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./source/config/config.mjs","webpack:///./source/config/webpack.config.mjs","webpack:///./source/public/js/fclone.mjs","webpack:///./source/public/js/global.mjs","webpack:///./source/server/auth.mjs","webpack:///./source/server/db.mjs","webpack:///./source/server/global-server.mjs","webpack:///./source/server/index.mjs","webpack:///./source/server/live-data-server.mjs","webpack:///./source/server/routes.mjs","webpack:///./source/source-path.cjs","webpack:///external \"bcryptjs\"","webpack:///external \"clean-webpack-plugin\"","webpack:///external \"dotenv\"","webpack:///external \"events\"","webpack:///external \"fs\"","webpack:///external \"html-webpack-plugin\"","webpack:///external \"http\"","webpack:///external \"koa\"","webpack:///external \"koa-bodyparser\"","webpack:///external \"koa-router\"","webpack:///external \"koa-send\"","webpack:///external \"koa-session\"","webpack:///external \"koa-webpack\"","webpack:///external \"minimist\"","webpack:///external \"node-fetch\"","webpack:///external \"path\"","webpack:///external \"pg-promise\"","webpack:///external \"socket.io\"","webpack:///external \"spotify-web-api-node\"","webpack:///external \"vue-loader/lib/plugin.js\"","webpack:///external \"webpack\"","webpack:///external \"webpack-node-externals\""],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AACA;AAC4B;AAC5B,mCAAM,SAAS,sBAAsB,EAAE,gC;;;;;;;;;;;;ACHvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAE4C;AACd;AACS;AACvC,2BAA2B,iDAAG;AACsB;AACG;AACJ;;AAE5C;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,MAAM,oCAAO;AACb;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA,MAAM,6CAAU;AAChB,EAAE;AACF;AACA;AACA;AACA,QAAQ,6CAAU;AAClB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,uBAAuB,6CAAU;AACjC,QAAQ;AACR,4BAA4B,qBAAqB,YAAY,GAAG,EAAE;AAClE,OAAO;AACP,MAAM;AACN;AACA,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA,MAAM,qDAAe;AACrB,MAAM,gDAAiB;AACvB,aAAa,6CAAU,WAAW,oBAAoB;AACtD,GAAG;AACH;AACA,CAAC;AACM;AACP;AACA;AACA;AACA,SAAS,6CAAU;AACnB,EAAE;AACF;AACA;AACA,QAAQ,6CAAU;AAClB,EAAE;AACF;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,mDAAa;AACf;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC,E;;;;;;;;;;;;ACrJD;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,WAAW;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,qEAAM,E;;;;;;;;;;;;AC7DrB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,IAAI;AAClC,oBAAoB,GAAG,gBAAgB;;AAEvC;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0FAA0F;;AAE1F;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEkC;AAClC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;;AAEA;AACA,yCAAyC,+BAA+B;AACxE,sCAAsC,UAAU,cAAc,MAAM;AACpE,0CAA0C;AAC1C;AACA;AACA,CAAC,EAAE;AACH,yCAAyC;AACzC;AACA;AACA,CAAC,EAAE;;;AAGH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO,kBAAkB,QAAQ;AACrD;AACA;AACA,EAAE;;AAEF;AACA,mBAAmB,OAAO;AAC1B;AACA,EAAE;AACF;AACA;AACA;AACA,2BAA2B,MAAM;AACjC,gBAAgB,gBAAgB;AAChC;AACA;AACA,8BAA8B,MAAM;AACpC,EAAE;AACF;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,gCAAgC,GAAG;AACnC,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,OAAO;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA,YAAY,wBAAwB,GAAG,6BAA6B;AACpE,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI,GAAG,EAAE;AACvB,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA,2BAA2B;;AAE3B;AACA,oEAAoE;AACpE,wCAAwC;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe,GAAG,eAAe,aAAa,OAAO,GAAG,OAAO;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV,EAAE,E;;AAEF;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,iBAAiB;AACjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,QAAQ,2DAAM;AACd;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA,sBAAsB;AACtB;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yF;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA,0BAA0B;AAC1B,yDAAyD;;AAEzD;AACA;AACA,8BAA8B,gEAAgE;AAC9F;;AAEA,qDAAqD;AACrD;AACA,kCAAkC;AAClC;AACA;AACA,uEAAuE,IAAI,IAAI,OAAO,IAAI,OAAO;AACjG;AACA,IAAI;AACJ;AACA,mCAAmC;AACnC;AACA;AACA,wEAAwE,IAAI,IAAI,OAAO,IAAI,OAAO;AAClG;AACA,KAAK;AACL;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA,qEAAqE,EAAE,IAAI,KAAK,IAAI,KAAK;AACzF;AACA,KAAK,OAAO;AACZ;AACA;AACA,oEAAoE,IAAI;AACxE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,sEAAsE,EAAE,IAAI,KAAK,IAAI,KAAK;AAC1F;AACA,MAAM;AACN;AACA;AACA,qEAAqE,IAAI;AACzE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,qBAAqB;AAChF,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA,2DAA2D,oBAAoB;AAC/E,8DAA8D,kBAAkB;AAChF,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA,wDAAwD;AACxD;AACA,+DAA+D,+BAA+B;AAC9F,kEAAkE,SAAS;AAC3E,8DAA8D,oBAAoB;AAClF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,gCAAgC,sBAAsB;AACtD,GAAG;AACH;AACA;AACA,EAAE;AACF,+BAA+B,aAAa;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA,2FAA2F,mCAAmC,EAAE;AAChI;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,eAAe,iBAAiB;AAChC;AACA;;AAEA;AACA;AACA;AACA,6C;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE,GAAG,uBAAuB;AAC5B;;AAEA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA,iCAAiC;AACjC;AACA,EAAE,mBAAmB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA,E;AACA,yEAAyE;AACzE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6HAA6H;;AAE7H;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA,gIAAgI,iBAAiB;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA,iD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uBAAuB;AACtF;AACA,kCAAkC;AAClC;AACA,qCAAqC;AACrC;AACA,kCAAkC;AAClC,EAAE;AACF;;;AAGA;AACA;AACA,8EAA8E,eAAe,KAAK;AAClG;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,uBAAuB;AACvB,eAAe;AACf;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA,kCAAkC;AAClC,qCAAqC;AACrC,kCAAkC;AAClC,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kD;AACA;AACA,UAAU,aAAa,UAAU;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,oIAAoI,MAAM,SAAS;AACnJ;AACA,wBAAwB,qBAAqB,GAAG,YAAY,GAAG,aAAa;AAC5E,GAAG;AACH,uBAAuB,qBAAqB,GAAG,YAAY,GAAG,aAAa;AAC3E,GAAG;AACH,sBAAsB,qBAAqB,GAAG,YAAY,GAAG,aAAa,IAAI,WAAW,GAAG;AAC5F;AACA;;AAEA,wCAAwC;AACxC,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;;AAEtC;AACA,+C;;AAEA;AACA;AACA,8BAA8B,QAAQ;;AAEtC;AACA;AACA,4E;AACA;AACA,mG;AACA;AACA,mCAAmC;;AAEnC;AACA,8BAA8B,QAAQ;;AAEtC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH,EAAE,E;AACF,kBAAkB,mDAAmD;AACrE,mBAAmB,oBAAoB;;AAEvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE,E;AACF;;AAEA,4CAA4C,E;AAC5C;;AAEA,4CAA4C,E;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE,E;AACF;;AAEA,6CAA6C,E;AAC7C;;AAEA,yCAAyC,E;AACzC;;AAEA,yCAAyC,E;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE;AACF;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe,uCAAuC,iBAAiB;AACrF,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe,oCAAoC,wBAAwB;AACzF,IAAI;;AAEJ;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,eAAe,aAAa,4BAA4B;AACxE;AACA,IAAI;AACJ,GAAG;AACH;AACA,cAAc,eAAe,mBAAmB,SAAS,OAAO,SAAS;;AAEzE;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,kBAAkB,EAAE;AACpB;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,kBAAkB,EAAE;AACpB;AACA,MAAM;AACN;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,YAAY;AAC3B;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA,IAAI;AACJ;AACA,gBAAgB,YAAY;AAC5B;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,I;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,I;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,aAAa,cAAc;AAC5D,MAAM;AACN;AACA;AACA;AACA;;;AAGA;AACA,sBAAsB,eAAe,mBAAmB,SAAS,OAAO,SAAS;AACjF;AACA,mBAAmB,QAAQ;AAC3B,MAAM;AACN,mBAAmB,QAAQ;AAC3B;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,6B;AACA;AACA;AACA,+B;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,KAAK;AAC9E;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,0E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA,OAAO;AACP;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;AACD,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,EAAE,EAAE,IAAI;AAChC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,yBAAyB,gCAAgC;AACzD,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,8EAA8E,UAAU;AACxF,KAAK;AACL,IAAI;;AAEJ;AACA,6S;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF,KAAK;AACL,IAAI;;AAEJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ,yDAAyD;AACzD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ,6DAA6D;AAC7D;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD,+CAA+C,MAAM;AACrD,KAAK;AACL,IAAI;AACJ,8BAA8B,gCAAgC;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,U;AACA,gE;AACA,MAAM,a;AACN;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;;AAGD;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,wB;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA,cAAc,uDAAuD,GAAG;AACxE,IAAI;AACJ,GAAG,E;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;;AAEA,6CAA6C;AAC7C,wCAAwC;AACxC,6BAA6B;AAC7B,gDAAgD;AAChD,mFAAmF;AACnF;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;AACA;AACA,qCAAqC;AACrC,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF;AACA;AACA,sEAAsE,OAAO;AAC7E,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,aAAa;AACb,cAAc;AACd,gBAAgB;AAChB,GAAG;AACH,EAAE;AACF,CAAC;;;AAGc,iEAAE,EAAC;;;AAGlB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iB;;;;;;;;;;;;ACt0GA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACkC;;AAElC;AACA;AACiD;;AAEjD;AACqC;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mCAAY;;AAEhC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA,iBAAiB,0DAAE;AACnB;AACA;AACA,sBAAsB,0DAAE;AACxB,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAAE,eAAe,0DAAE;AACnB;AACA,aAAa,iDAAa;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO,0DAAE;AACT,GAAG,0DAAE;AACL,GAAG,0DAAE;AACL,sBAAsB,0DAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,+EAA+E,yBAAyB;AACxG,KAAK;AACL,CAAC;AACD;AACA,cAAc,0DAAE;AAChB;AACA;AACA,aAAa,0DAAE;AACf;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM,0DAAE;AACR,iCAAiC,0DAAE;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,OAAO,0DAAE;AACT,iCAAiC,0DAAE;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,gCAAgC,0DAAE,cAAc;AAChD;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA,iDAAiD;AACjD;AACA;AACA;AACA,IAAI;;AAEJ;AACA,GAAG,0DAAE;AACL,eAAe,0DAAE;AACjB;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,0DAAE,2DAA2D,0DAAE;AACpF;AACA;AACA;;AAEA;AACA;AACA,2GAA2G,QAAQ,8BAA8B,GAAG,kCAAkC,GAAG;AACzL,GAAG,GAAG,0DAAE;AACR,aAAa,0DAAE;AACf;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA,iBAAiB,0DAAE,uBAAuB,0DAAE;AAC5C,QAAQ,0DAAE,YAAY,qDAAqD;AAC3E,GAAG;;AAEH;AACA,aAAa,0DAAE;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,iBAAiB,0DAAE,uBAAuB,0DAAE;AAC5C,2BAA2B,0DAAE,mBAAmB,0DAAE,eAAe,0DAAE;;AAEnE;AACA,MAAM,0DAAE;AACR,aAAa,0DAAE;AACf;;AAEA;AACA;AACA,qBAAqB,0DAAE,2DAA2D,0DAAE;AACpF;AACA;;AAEA;AACA;AACA,GAAG,GAAG,0DAAE;AACR,aAAa,0DAAE;AACf;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA,MAAM,0DAAE,0CAA0C;AAClD;AACA,SAAS,0DAAE,YAAY,qDAAqD,E;AAC5E;;AAEA;AACA,aAAa,0DAAE;AACf;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;;AAGD,0DAAE,eAAe,0DAAE;AACnB;AACA,CAAC;AACD,cAAc,0DAAE;AAChB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAEc,mEAAI,E;;;;;;;;;;;;ACtTnB;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AAC8B;AAC9B,YAAY,uCAAI;AAChB;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACe,iEAAE,EAAC;AACL;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH,EAAE;AACF,E;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;;AAEA,ySAAyS,IAAI;;AAE7S;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4TAA4T,OAAO,0HAA0H;;AAE7b,6NAA6N,UAAU;;AAEvO;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AAC+B;AACD;;AAE9B;AACyC;AACF;AACO;;;AAG9C;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAAE,SAAS,uCAAK;;AAEhB;AACA,sB;;AAEA;AACA,6DAAE,MAAM,+CAAQ,CAAC;;AAEjB;AACA,6DAAE,YAAY,6DAAQ;;;AAGtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,MAAM;AACN,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA,WAAW,6DAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,EAYV;;AAET;AACA;AACA;AACA;AACA,sBAAsB,6DAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,0BAA0B,6DAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,0BAA0B,6DAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,0BAA0B,6DAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,0BAA0B,6DAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,0BAA0B,6DAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT,kBAAkB,6DAAE;AACpB,SAAS;AACT,KAAK;AACL,cAAc,6DAAE;AAChB,KAAK;AACL,CAAC;AACD,QAAQ,6DAAE;AACV;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA,CAAC;;AAED,6DAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA,6DAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,IAAI,GAAG;AAChC,GAAG;;AAEH,iCAAiC;AACjC,iBAAiB,QAAQ,IAAI;;AAE7B;AACA,qBAAqB,aAAa;;AAElC;AACA,SAAS,2CAAG,cAAc,QAAQ,UAAU,aAAa;AACzD;AACA;AACA,6DAAE;AACF,8CAA8C;AAC9C;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,eAAe,6DAAE;AACjB,UAAU,2CAAG,eAAe,IAAI,gBAAgB;AAChD,GAAG;;AAEH;AACA;AACA;AACA;AACA,6DAAE;AACF,8CAA8C;AAC9C;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,eAAe,6DAAE;AACjB,UAAU,2CAAG,eAAe,IAAI;AAChC,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAAE;AACF;AACA,mBAAmB,6DAAE,6CAA6C,6DAAE;AACpE,uBAAuB,6DAAE,qDAAqD,6DAAE,UAAU;;AAE1F;AACA;AACA;AACA,KAAK;AACL,cAAc,6DAAE,kCAAkC,6DAAE;AACpD;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA,wBAAwB,qCAAM;AAC9B,kBAAkB,6DAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,kBAAkB,6DAAE;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,cAAc,6DAAE,kCAAkC,6DAAE;AACpD;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL,2BAA2B,6DAAE;AAC7B,eAAe,6DAAE;AACjB;AACA;AACA;AACA,KAAK;AACL;AACA,6DAAE;AACF,UAAU,6DAAE;AACZ,eAAe,6DAAE;AACjB;AACA;AACA,KAAK;AACL;AACA,6DAAE;AACF;AACA,eAAe,6DAAE;AACjB;AACA;AACA,KAAK;AACL;;AAEA;AACA,6DAAE;AACF,SAAS,6DAAE,0BAA0B,6DAAE,WAAW,6DAAE;AACpD,kBAAkB,6DAAE;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO,6DAAE;;AAET;;AAEA,eAAe,6DAAE;AACjB;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,yCAAyC,6DAAE;AAC3C;AACA;AACA,yCAAyC,6DAAE;AAC3C;AACA;AACA,0CAA0C,6DAAE;AAC5C;AACA;AACA,4CAA4C,6DAAE;AAC9C;AACA;AACA,8CAA8C,6DAAE;AAChD;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAgB,6DAAE,mBAAmB,6DAAE;AACvC;AACA;AACA,IAAI;;AAEJ;AACA,oBAAoB,6DAAE;;AAEtB;AACA,gDAAgD;AAChD,sCAAsC;AACtC;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA,oCAAoC,6DAAE,4FAA4F,6DAAE;;AAEpI;AACA,mCAAmC,6DAAE,8GAA8G,6DAAE;;AAErJ;AACA,mHAAmH,6DAAE;;AAErH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,6DAAE;AACb;AACA;AACA,6CAA6C,6DAAE,sCAAsC,6DAAE,YAAY,6DAAE;AACrG;AACA;;AAEA;AACA,mEAAmE,6DAAE,YAAY,6DAAE;AACnF;AACA,MAAM;AACN,YAAY,6DAAE,eAAe,6DAAE;AAC/B;AACA;AACA,OAAO;AACP,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,WAAW,6DAAE;AACb,4CAA4C,6DAAE,gDAAgD,6DAAE,YAAY,6DAAE;AAC9G;;AAEA,mEAAmE,6DAAE,YAAY,6DAAE;AACnF;AACA,MAAM;AACN,YAAY,6DAAE,eAAe,6DAAE;AAC/B;AACA;AACA,OAAO;AACP,MAAM;AACN;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,6DAAE,+FAA+F,6DAAE;AACpH,IAAI,QAAQ,6DAAE,YAAY;;AAE1B;AACA,sCAAsC,6DAAE;;AAExC;AACA;;AAEA;AACA,wCAAwC,6DAAE;AAC1C;AACA,2C;;AAEA;AACA,mCAAmC,6DAAE;;AAErC;AACA;;AAEA,cAAc,6DAAE;AAChB;AACA;AACA;AACA;AACA,IAAI;AACJ;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,6DAAE;AACX;;AAEA;AACA,+BAA+B,6DAAE,SAAS;AAC1C,eAAe,6DAAE;AACjB;AACA;AACA;AACA,iBAAiB,IAAI;AACrB;AACA,MAAM;AACN;;AAEA;AACA,oCAAoC,6DAAE;AACtC;AACA;AACA,sBAAsB,6DAAE;AACxB;AACA,KAAK;AACL;AACA,gBAAgB,6DAAE;AAClB;AACA,2BAA2B,IAAI;AAC/B,MAAM;AACN;AACA,IAAI;AACJ,cAAc,6DAAE;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,wCAAwC;AACxC,SAAS,6DAAE,qCAAqC,6DAAE,+CAA+C;AACjG,8DAA8D;AAC9D,MAAM;AACN,wDAAwD,IAAI;AAC5D;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,qDAAqD;AACrD,gGAAgG;AAChG,SAAS,6DAAE;AACX;AACA;AACA,MAAM;AACN,wDAAwD,WAAW;AACnE;AACA,KAAK;AACL;AACA,IAAI;AACJ;;AAEA;AACA,wC;;AAEA;AACA;AACA,gBAAgB,6DAAE;;AAElB;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,mC;AACA,UAAU,6DAAE,kCAAkC,6DAAE;AAChD;AACA,mBAAmB,UAAU;AAC7B,+BAA+B,UAAU;AACzC,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA,eAAe,6DAAE;;AAEjB;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA,MAAM;AACN;AACA,UAAU,6DAAE,kCAAkC,6DAAE;AAChD;AACA,mBAAmB,UAAU;AAC7B,+BAA+B,UAAU;AACzC,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA,QAAQ,uBAAuB;AAC/B,aAAa,6DAAE;AACf,eAAe,6DAAE,aAAa,GAAG;;AAEjC;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,UAAU,6DAAE,kCAAkC,6DAAE;AAChD;AACA,mBAAmB,UAAU;AAC7B,gCAAgC,WAAW;AAC3C,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA,eAAe,6DAAE;;AAEjB;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA,UAAU,6DAAE,kCAAkC,6DAAE;AAChD;AACA,mBAAmB,UAAU;AAC7B,kCAAkC,WAAW;AAC7C,KAAK;AACL,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,iBAAiB,UAAU;AAC3B,qBAAqB,UAAU;AAC/B;AACA,iCAAiC;AACjC,iBAAiB,UAAU;AAC3B,yBAAyB,UAAU;AACnC;AACA,kCAAkC;AAClC,iBAAiB,UAAU;AAC3B,sBAAsB,UAAU;AAChC;AACA,oCAAoC;AACpC,iBAAiB,UAAU;AAC3B,uBAAuB,UAAU;AACjC;;AAEA,+BAA+B;AAC/B,iBAAiB,UAAU;AAC3B,6BAA6B,UAAU;AACvC;AACA,+BAA+B;AAC/B,iBAAiB,UAAU;AAC3B,kCAAkC,UAAU;AAC5C;AACA,gCAAgC;AAChC,iBAAiB,UAAU;AAC3B,8BAA8B,UAAU;AACxC;AACA,kCAAkC;AAClC,iBAAiB,UAAU;AAC3B,gCAAgC,UAAU;AAC1C;AACA,EAAE;AACF,CAAC;;AAED,6DAAE;AACF;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,6DAAE,4DAA4D,qCAAM;AAC3E,cAAc,6DAAE;AAChB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;;AAEA;AACA,EAAE;AACF,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAAE;AACF;AACA;AACA;AACA,EAAE;AACF,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA,6DAAE;AACF;AACA,oCAAoC,6DAAE;AACtC,2CAA2C,6DAAE;AAC7C;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAE,kCAAkC,6DAAE;AAC1D;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,QAAQ,6DAAE;AACV,+BAA+B,6DAAE,YAAY,gCAAgC,UAAU,6DAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6DAAE,kCAAkC,6DAAE;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,2CAA2C,6DAAE,gBAAgB,6DAAE;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,6DAAE;AACtB,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM,6DAAE;AACR;AACA,SAAS,6DAAE,wDAAwD,6DAAE,6B;AACrE;AACA;;AAEA;AACA;AACA,eAAe,6DAAE;AACjB;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU,6DAAE;AACZ;AACA,WAAW,6DAAE,0CAA0C,6DAAE;AACzD;AACA,gDAAgD,WAAW;AAC3D,OAAO;AACP,oDAAoD,6DAAE;AACtD;AACA,kDAAkD,eAAe;AACjE,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,OAAO,2CAAG;AACV;AACA;AACA;AACA;AACA,OAAO,2CAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAE,kCAAkC,6DAAE;AAClD;AACA;AACA;AACA,OAAO;AACP,MAAM;;;AAGN;AACA,uIAAuI;AACvI;AACA;AACA;AACA,MAAM;;;AAGN,UAAU,6DAAE,wF;AACZ;AACA;AACA;AACA,MAAM,O;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAE,kCAAkC,6DAAE;AACnD;AACA;AACA;AACA,QAAQ;AACR,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA,gBAAgB,6DAAE;AAClB;AACA;AACA,MAAM;AACN,KAAK;AACL,eAAe,6DAAE;AACjB;AACA;AACA;AACA,MAAM;AACN,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,6DAAE;AACb;AACA;AACA,MAAM;;;AAGN;AACA,KAAK,6DAAE;AACP;AACA,KAAK,6DAAE;AACP,KAAK,6DAAE;;AAEP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;;;AAG9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,eAAe,6DAAE;AACjB;AACA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;;AAGc,4HAAE,E;;;;;;;;;;;;AC/0CjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAC8B;;AAE9B;AACwB;;AAExB;AAC8B;AACR;AACe;AACG;AACN;;AAElC;AACiC;AACT;;AAExB;AAC4C;AACsC;AAC7C;AACH;;;AAGlC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,qCAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;;AAEA,qCAAqC;AACrC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,IAAI;;;AAGJ;;AAEA,eAAe,iFAAa,GAAG;AAC/B;AACA,CAAC;;AAED;AACA;AACA;AACA,8BAA8B,wCAAU;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;;AAEF;AACA,mBAAmB,iCAAI,6BAA6B,+EAAmB;AACvE;AACA;AACA;AACA;AACA,eAAe,4DAAM;;;;;AAKrB;;AAEA;AACA,gBAAgB,gCAAG;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,iCAAI;;AAEnB;AACA,qBAAqB,sCAAQ;AAC7B,2DAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG;AAC1C,EAAE;;AAEF;AACA;AACA,iBAAiB,mBAAmB,GAAG,iBAAiB;AACxD;AACA,EAAE;AACF;;AAEA;AACA,QAAQ,2CAAU;;AAElB;AACA,QAAQ,wCAAO;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,iC;;;AAGA;AACA,2DAAE;AACF;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;;AAGD,CAAC,I;;;;;;;;;;;;AC5PD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACwB;;AAExB;AACA;AACyC;;;AAGzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2IAA2I;;AAE3I;;AAEA,6DAAE;AACF;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF,CAAC;;AAEc;AACf;AACA;AACA,SAAS,6DAAE;;AAEX;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAI;AACnE;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,OAAO,6DAAE,6BAA6B,6DAAE;;AAExC;AACA;;AAEA,UAAU,6DAAE,mD;AACZ;AACA,SAAS,6DAAE,kBAAkB,6DAAE;AAC/B;AACA,KAAK;;AAEL;AACA,QAAQ,6DAAE,6BAA6B,6DAAE,uCAAuC,6DAAE;AAClF,IAAI;;AAEJ,kCAAkC,aAAa;AAC/C;;AAEA;AACA;AACA,iBAAiB,6DAAE,6BAA6B,6DAAE;AAClD;AACA,WAAW,6DAAE,OAAO,oBAAoB;;AAExC;AACA,yBAAyB,6DAAE,cAAc,6DAAE,iDAAiD,6DAAE;;AAE9F;AACA;AACA;AACA,aAAa,6DAAE,oB;AACf,IAAI;AACJ,oCAAoC,aAAa;AACjD;;AAEA,iBAAiB,6DAAE,6BAA6B,6DAAE;AAClD;AACA,WAAW,6DAAE,OAAO,oBAAoB;;AAExC,yBAAyB,6DAAE,iBAAiB,6DAAE,iDAAiD,6DAAE;AACjG,aAAa,6DAAE;AACf,IAAI;;AAEJ;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA,EAAE;AACF;AACA,6CAA6C,6DAAE,oCAAoC,kBAAkB;AACrG,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,yDAAyD,iBAAiB;AAC1E;;AAEA;AACA;AACA,OAAO,6DAAE,eAAe,6DAAE,uBAAuB,6DAAE;AACnD;AACA;AACA,GAAG;;AAEH;AACA;AACA,OAAO,6DAAE,mBAAmB,6DAAE;AAC9B,mBAAmB,6DAAE;AACrB;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,OAAO,6DAAE,sBAAsB,6DAAE;AACjC,sBAAsB,6DAAE;AACxB;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA,aAAa,6DAAE;AACf;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO,6DAAE,eAAe,6DAAE,uBAAuB,6DAAE;AACnD;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,OAAO,6DAAE,mBAAmB,6DAAE,8CAA8C,6DAAE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;AACA;AACA,OAAO,6DAAE,sBAAsB,6DAAE,oDAAoD,6DAAE;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,6DAAE;AACf;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,OAAO,6DAAE,eAAe,6DAAE,uBAAuB,6DAAE;AACnD;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAE;AACpC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC,EAAC;;AAEF;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACwB;AACJ;;AAEpB;AACgC;AACJ;;AAE5B;AAC4C;AACuB;AAC9B;AACP;;;AAG9B;AACA;AACA;AACA;AACA;AACA;;AAEe,0EAAW,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6CAAU;AACxB,iBAAiB,8EAAmB,CAAC;;AAErC;AACA,oBAAoB,uCAAM;AAC1B,uBAAuB,uCAAM;;;AAG7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0DAAE;AAC5B;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,4BAA4B,0DAAE,kCAAkC,0DAAE;AAClE,EAAE;AACF,qD;AACA;AACA;AACA,QAAQ,0DAAE,qDAAqD,0DAAE;AACjE,QAAQ,qCAAI,YAAY,WAAW;AACnC,EAAE;AACF;AACA,4BAA4B,0DAAE,gDAAgD,0DAAE;AAChF,EAAE;AACF;AACA,4BAA4B,0DAAE,oDAAoD,0DAAE;AACpF,EAAE;AACF;AACA,4BAA4B,0DAAE,iCAAiC,0DAAE;AACjE,EAAE;;AAEF;AACA,4BAA4B,0DAAE,gCAAgC,0DAAE;AAChE,EAAE;;;AAGF;AACA;AACA;AACA;AACA,4BAA4B,0DAAE,eAAe,0DAAE,kCAAkC,0DAAE;AACnF,EAAE;AACF;AACA;AACA,4BAA4B,0DAAE,wBAAwB,0DAAE;AACxD,EAAE;AACF;AACA,4BAA4B,0DAAE,2BAA2B,0DAAE;AAC3D,EAAE;;;AAGF;AACA,WAAW,0DAAE,YAAY;AACzB,4BAA4B,0DAAE,kCAAkC,0DAAE;AAClE,EAAE;AACF,UAAU,0DAAE,YAAY;AACxB,4BAA4B,0DAAE,UAAU,0DAAE,oCAAoC,0DAAE;AAChF,EAAE;AACF,YAAY,0DAAE,YAAY;AAC1B,4BAA4B,0DAAE,mCAAmC,0DAAE;AACnE,EAAE;AACF,aAAa,0DAAE,YAAY;AAC3B,4BAA4B,0DAAE,qCAAqC,0DAAE;AACrE,EAAE;;AAEF;AACA,WAAW,0DAAE,gBAAgB;AAC7B,4BAA4B,0DAAE,sCAAsC,0DAAE;AACtE,EAAE;AACF,UAAU,0DAAE,gBAAgB;AAC5B,4BAA4B,0DAAE,cAAc,0DAAE,oCAAoC,0DAAE;AACpF,EAAE;AACF,YAAY,0DAAE,gBAAgB;AAC9B,4BAA4B,0DAAE,uCAAuC,0DAAE;AACvE,EAAE;AACF,aAAa,0DAAE,gBAAgB;AAC/B,4BAA4B,0DAAE,yCAAyC,0DAAE;AACzE,EAAE;;AAEF;AACA,WAAW,0DAAE,aAAa;AAC1B,4BAA4B,0DAAE,mCAAmC,0DAAE;AACnE,EAAE;AACF,UAAU,0DAAE,aAAa;AACzB,4BAA4B,0DAAE,WAAW,0DAAE,oCAAoC,0DAAE;AACjF,EAAE;AACF,YAAY,0DAAE,aAAa;AAC3B,4BAA4B,0DAAE,oCAAoC,0DAAE;AACpE,EAAE;AACF,aAAa,0DAAE,aAAa;AAC5B,4BAA4B,0DAAE,sCAAsC,0DAAE;AACtE,EAAE;;AAEF;AACA;AACA,0BAA0B,0DAAE;AAC5B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA,oE;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,+BAAE,YAAY,iCAAI;AACxB,SAAS,qCAAI,yBAAyB,WAAW;AACjD;AACA;AACA;AACA,G;;AAEA;AACA,MAAM,0DAAE,kGAAkG;AAC1G,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA,M;AACA;AACA;AACA;AACA,SAAS,qCAAI,YAAY,WAAW;AACpC;AACA,EAAE;AACF;AACA;AACA,4BAA4B;AAC5B,EAAE,E;;AAEF;AACA,CAAC;;;;;;;;;;;;AC/SD;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO,QAAQ,GAAG,mBAAO,CAAC,kBAAM;AAChC;;;;;;;;;;;;;ACtBA,qC;;;;;;;;;;;ACAA,iD;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,gD;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,2C;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,wC;;;;;;;;;;;ACAA,qC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,sC;;;;;;;;;;;ACAA,iD;;;;;;;;;;;ACAA,qD;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,mD","file":"index.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./source/server/index.mjs\");\n","//! this needs to be in its own file (not at the top of index.mjs) because imports are hoisted, which causes dotenv.config() to run after any module that uses environment variables immediately, which makes them undefined\r\n//L https://stackoverflow.com/questions/42817339/es6-import-happening-before-env-import\r\nimport dotenv from 'dotenv';\r\ndotenv.config({path: './config/.env'}); //C relative to root apparently","//R Not all modules on npm are 'bundle-able' or compatible with non-Node environments: bcrypt is written in C. This was causing errors when trying to bundle server-side code with Webpack, it just wasn't able to. Used bcryptjs instead.\r\n//R Unless nodeExternals is used, in which case node_modules are ignored and a node environment is assumed.\r\n\r\n/* Build Type Table\r\n\r\n\r\n\tBuild Method \\ Target             | Client                          | Server\r\n\t___________________________________________________________________________________________________________          \r\n\tHot      (init + auto update)     | webpack + w-hot + server        | (webpack + w-hot + w-server) + node\r\n\t___________________________________________________________________________________________________________\r\n\tRefresh  (init + auto refresh)    | webpack + w-middleware + server | webpack watch + nodemon\r\n\t___________________________________________________________________________________________________________\r\n\tWatch    (init + manual refresh)  | webpack watch + server          | webpack watch + node\r\n\t___________________________________________________________________________________________________________\r\n\tCompile  (build + manual refresh) | webpack + server                | webpack + node\r\n\t___________________________________________________________________________________________________________\r\n\tRaw      (manual refresh)         | server                          | node\r\n\r\n\r\n\t[Client x Hot] and [Client x Refresh] \r\n\t\tRequire build initialization from the server side.\r\n\t\tOnly useful when running client code, therefore should not be used without a running server.\r\n\t\tMay use a webpack-dev-server instead of the homebrew server.\r\n\r\n\t[Server]\r\n\t\tCan only configure the watch mode of the Client, not itself.\r\n\t\tIts own watch mode must be set by whatever process starts the server.\r\n\r\n\t[Raw]\r\n\t\tNot relevant where webpack has been setup for Client and/or Server.\r\n*/\r\n\r\n//TODO Start off by doing a single startup command for refresh of both client and server.\r\n\r\nimport sourcePath from '../source-path.cjs';\r\nimport webpack from 'webpack';\r\nimport CWP from 'clean-webpack-plugin';\r\nconst CleanWebpackPlugin = CWP.CleanWebpackPlugin;\r\nimport HtmlWebpackPlugin from 'html-webpack-plugin';\r\nimport VueLoaderPlugin from 'vue-loader/lib/plugin.js';\r\nimport nodeExternals from 'webpack-node-externals';\r\n\r\nexport const clientIndexFileName = 'index.html';\r\n\r\n// COMMON\r\nconst common = {\r\n\toptions: (env, argv) => ({\r\n\t\t//L https://webpack.js.org/configuration/mode\r\n\t\tmode: argv.mode,\r\n\t\t//L https://webpack.js.org/configuration/devtool\r\n\t\t//! 'eval-source-map' doesn't seem to work with source-map-support.\r\n\t\t//L https://www.npmjs.com/package/source-map-support\r\n\t\tdevtool: argv.mode === 'development' ? 'source-map' : undefined,\r\n\t}),\r\n\tplugins: (env, argv) => ([\r\n\t\tnew CleanWebpackPlugin(),\r\n\t\tnew webpack.ProgressPlugin(),\r\n\t]),\r\n};\r\n\r\n// TARGETS\r\nexport const clientOptions = (env, argv) => ({\r\n\t...common.options(env, argv),\r\n\ttarget: 'web',\r\n\tentry: {\r\n\t\tjs: sourcePath('public/js/index.mjs'),\r\n\t},\r\n\toutput: {\r\n\t\tfilename: 'index.bundle.js',\r\n\t\tchunkFilename: '[name].chunk.js',\r\n\t\tpath: sourcePath('../build/public'),\r\n\t\t//TODO This is explicitly required for webpack-dev-middleware, not 100% sure what it should be yet though.\r\n\t\t//publicPath: 'dist/', //C the prefix that gets added to resource requests, //L publicPath is just a prefix and needs a following '/': https://github.com/GoogleChrome/workbox/issues/1548\r\n\t\t//TODO consider tossing not-yet-bundled resources into dist too (clientIndex, css)\r\n\t\tpublicPath: '/', \r\n\t},\r\n\tmodule: {\r\n\t\trules: [\r\n\t\t\t{\r\n\t\t\t\t//L https://vue-loader.vuejs.org/guide/#manual-configuration\r\n\t\t\t\ttest: /\\.vue$/,\r\n\t\t\t\tloader: 'vue-loader',\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\ttest: /\\.css$/,\r\n\t\t\t\tuse: [\r\n\t\t\t\t\t'vue-style-loader',\r\n\t\t\t\t\t'css-loader',\r\n\t\t\t\t],\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\t//L https://vue-loader.vuejs.org/guide/pre-processors.html#sass\r\n\t\t\t\ttest: /\\.scss$/,\r\n\t\t\t\tuse: [\r\n\t\t\t\t\t'vue-style-loader',\r\n\t\t\t\t\t'css-loader',\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tloader: 'sass-loader',\r\n\t\t\t\t\t\toptions: {\r\n\t\t\t\t\t\t\t//! Apparently breaks sass source-maps.\r\n\t\t\t\t\t\t\tprependData: `@import 'global.scss';`,\r\n\t\t\t\t\t\t\tsassOptions: {\r\n\t\t\t\t\t\t\t\tincludePaths: [sourcePath('public/css')],\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t// data: `@import '${sourcePath(`public/${clientIndex}`)}';`,\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t],\r\n\t\t\t},\r\n\t\t],\r\n\t},\r\n\tplugins: [\r\n\t\t...common.plugins(env, argv),\r\n\t\tnew VueLoaderPlugin(),\r\n\t\tnew HtmlWebpackPlugin({\r\n\t\t\ttemplate: sourcePath(`public/${clientIndexFileName}`),\r\n\t\t}),\r\n\t],\r\n});\r\nexport const serverOptions = (env, argv) => ({\r\n\t...common.options(env, argv),\r\n\ttarget: 'node',\r\n\tentry: {\r\n\t\tindex: sourcePath('server/index.mjs'),\r\n\t},\r\n\toutput: {\r\n\t\tfilename: 'index.bundle.js',\r\n\t\tpath: sourcePath('../build/server'),\r\n\t},\r\n\tplugins: [\r\n\t\t...common.plugins(env, argv),\r\n\t\t/* //OLD Only required if bundling node_modules\t\r\n\t\t\tconst {IgnorePlugin} = require('webpack');\r\n\t\t\t//L Required to patch pg-promise: https://github.com/serverless-heaven/serverless-webpack/issues/78#issuecomment-405646040\r\n\t\t\tnew IgnorePlugin(/^pg-native$/),\r\n\t\t\t//L Required to patch socket.io: https://github.com/socketio/engine.io/issues/575#issuecomment-578081012\r\n\t\t\tnew IgnorePlugin(/^uws$/),\r\n\t\t*/\r\n\t],\r\n\texternals: [\r\n\t\t//C Don't bundle node_modules.\r\n\t\tnodeExternals(),\r\n\t],\r\n\tnode: {\r\n\t\t//C Required for source-path.cjs to work properly.\r\n\t\t//R Still won't work properly on its own though.\r\n\t\t__dirname: true,\r\n\t\t//TODO __filename, when it's needed.\r\n\t},\r\n});","// see if it looks and smells like an iterable object, and do accept length === 0\r\nfunction isArrayLike(item) {\r\n  if (Array.isArray(item)) return true;\r\n\r\n  const len = item && item.length;\r\n  return typeof len === 'number' && (len === 0 || (len - 1) in item) && typeof item.indexOf === 'function';\r\n}\r\n\r\nfunction fclone(obj, refs) {\r\n  if (!obj || \"object\" !== typeof obj) return obj;\r\n\r\n  if (obj instanceof Date) {\r\n    return new Date(obj);\r\n  }\r\n\r\n  if (typeof Buffer !== 'undefined' && Buffer.isBuffer(obj)) {\r\n    return new Buffer(obj);\r\n  }\r\n\r\n  // typed array Int32Array etc.\r\n  if (typeof obj.subarray === 'function' && /[A-Z][A-Za-z\\d]+Array/.test(Object.prototype.toString.call(obj))) {\r\n    return obj.subarray(0);\r\n  }\r\n\r\n  if (!refs) { refs = []; }\r\n\r\n  if (isArrayLike(obj)) {\r\n    refs[refs.length] = obj;\r\n    let l = obj.length;\r\n    let i = -1;\r\n    let copy = [];\r\n\r\n    while (l > ++i) {\r\n      copy[i] = ~refs.indexOf(obj[i]) ? '[Circular]' : fclone(obj[i], refs);\r\n    }\r\n\r\n    refs.length && refs.length--;\r\n    return copy;\r\n  }\r\n\r\n  refs[refs.length] = obj;\r\n  let copy = {};\r\n\r\n  if (obj instanceof Error) {\r\n    copy.name = obj.name;\r\n    copy.message = obj.message;\r\n    copy.stack = obj.stack;\r\n  }\r\n\r\n  let keys = Object.keys(obj);\r\n  let l = keys.length;\r\n\r\n  while(l--) {\r\n    let k = keys[l];\r\n    copy[k] = ~refs.indexOf(obj[k]) ? '[Circular]' : fclone(obj[k], refs);\r\n  }\r\n\r\n  refs.length && refs.length--;\r\n  return copy;\r\n}\r\n\r\nexport default fclone;","//      \r\n//   \r\n//             \r\n//            \r\n//        \r\n//           \r\n\r\n/*\r\n\t//G JAVASCRIPT GUIDES\r\n\t\t//L Default arguments and parameter destructuring: https://simonsmith.io/destructuring-objects-as-function-parameters-in-es6/\r\n\t\t\r\n\t\t//L nesting optimization: https://thorstenlorenz.wordpress.com/2012/06/02/performance-concerns-for-nested-javascript-functions/\r\n\r\n\t\tPromises: promises always return more promises (that are resolved or rejected), await (and furthermore async) is only needed to transform those resolved or rejected promises in to useable values, promises can be called and returned within a synchronous function (like map) they just pass on their evaluation to whatever they were returned to (see the implementation of Promise.all(...map()))\r\n\t\t//G catches should be attached behind every async function and not paired next to .then() - this straightens out the chain ordering (as opposed to two steps forward, one step back -style), this also stops upstream errors from triggering all downstream catches and nesting every error\r\n\t\t\r\n\t\t//L Arrow Functions: when not to use - https://dmitripavlutin.com/when-not-to-use-arrow-functions-in-javascript/\r\n\r\n\t\t//L es modules: https://developers.google.com/web/fundamentals/primers/modules, http://2ality.com/2014/09/es6-modules-final.html\r\n\t\t//L export: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export\r\n\t\t//L import: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\r\n\t\t//L es modules in node (VERY USEFUL FOR HOW TO CONVERT TO ES MODULES): https://medium.com/@giltayar/native-es-modules-in-nodejs-status-and-future-directions-part-i-ee5ea3001f71\r\n\r\n\t\t//G Object.assign(sj.Base, {...}) is used to assign static variables and methods\r\n\t\t//G (function () {..}).call(sj.Base); is better \r\n\r\n\t\t//G use guard clauses over else statements where possible - because they keep the relative error close by in the script (rather than way down below at the bottom of an else statement or early escape function (using positively phrased clauses)) - see sj.rebuild()\r\n\r\n\t\t//C arrow functions can have an implicit return, but for object literals, they need to be wrapped in parenthesis to be distinguished from the function block \r\n\t\t//L https://www.sitepoint.com/es6-arrow-functions-new-fat-concise-syntax-javascript/\r\n\r\n\t\t//L classes: https://medium.com/@robertgrosse/how-es6-classes-really-work-and-how-to-build-your-own-fd6085eb326a\r\n\r\n\t\t//L prototypes explained: https://hackernoon.com/understand-nodejs-javascript-object-inheritance-proto-prototype-class-9bd951700b29\r\n\t\t'The prototype is a property on a constructor function that sets what will become the __proto__ property on the constructed object.'\r\n\r\n\t\t//L beware the comma operator in if-statements: https://stackoverflow.com/questions/5347995/why-does-javascript-accept-commas-in-if-statements\r\n\r\n\t//G STYLE GUIDES\r\n\t\t//R use null in places where there should be an manually placed empty value - distinguishes between unintentional empty values: undefined, and intentional empty values: null\r\n\t\t//L \"To distinguish between the two, you may want to think of undefined as representing an unexpected absence of value and null as representing an expected absence of value.\"\r\n    \t//L http://ryanmorr.com/exploring-the-eternal-abyss-of-null-and-undefined/\r\n\t\t\r\n\r\n\t//L DEV TOOLS\r\n\t\t//L ASCII TITLE GENERATOR: http://patorjk.com/software/taag/#p=display&c=c%2B%2B&f=ANSI%20Shadow&t=playlist\r\n\t\t//L Console css formatting https://developers.google.com/web/tools/chrome-devtools/console/console-write#styling_console_output_with_css\r\n\t\r\n\t//L LIBRARIES\r\n\t\t//L fetch vs axios: https://www.reddit.com/r/javascript/comments/6e0o99/fetch_polyfill_or_axios/\r\n\t\t//R axios is high level, fetch is middle level - i want this because its less magic, i actually want the functionality of fetch to be able to distinguish between failed requests and bad requests, i'm making a wrapper function anyways so the extra detail doesn't matter\r\n*/\r\n\r\n\r\n//       \r\n//  \r\n//                \r\n//                \r\n//        \r\n//             \r\n\r\n/* \r\n\t// BIG\r\n\t\tBreak every single part of every module, see if all possible outcomes are caught and handled properly.\r\n\r\n\t\tEnsure everything has an error handler - most of the time 'throw sj.propagate(rejected);'.\r\n\r\n\t\tFill in and make consistent content for all success, error, data objects.\r\n\r\n\t\tAdd timeouts to async functions.\r\n\r\n\t\tReplace all 'var' with 'let' and 'const'\r\n\r\n\r\n\t// SMALL\r\n\t\teslint + prettier configuration\r\n\t\t//L https://medium.com/@pgivens/write-cleaner-code-using-prettier-and-eslint-in-vscode-d04f63805dcd\r\n*/\r\n\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//          \r\n\r\nlet sj = {};\r\n\r\nsj.appName = 'StreamJockey';\r\n\r\nimport fClone from './fclone.mjs'; //L https://github.com/soyuka/fclone\r\nif (typeof fetch !== 'undefined') {\r\n\t//L typeof doesn't throw reference error: https://stackoverflow.com/questions/5113374/javascript-check-if-variable-exists-is-defined-initialized\r\n\t//L fetch also needs the window context: https://stackoverflow.com/questions/10743596/why-are-certain-function-calls-termed-illegal-invocations-in-javascript\r\n\tsj.fetch = fetch.bind(window);\r\n} else {\r\n\tsj.fetch = async function () {\r\n\t\tthrow new sj.Error({\r\n\t\t\tlog: true,\r\n\t\t\torigin: 'global.mjs init',\r\n\t\t\treason: 'fetch is not defined',\r\n\t\t});\r\n\t}\r\n}\r\nif (!Array.prototype.flat) {\r\n    //L https://github.com/jonathantneal/array-flat-polyfill\r\n\tObject.defineProperties(Array.prototype, {\r\n\t\tflat: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tvalue: function flat() {\r\n\t\t\t\tlet depth = isNaN(arguments[0]) ? 1 : Number(arguments[0]);\r\n\t\t\t\tconst stack = Array.prototype.slice.call(this);\r\n\t\t\t\tconst result = [];\r\n\r\n\t\t\t\twhile (depth && stack.length) {\r\n\t\t\t\t\tconst next = stack.pop();\r\n\r\n\t\t\t\t\tif (Object(next) instanceof Array) {\r\n\t\t\t\t\t\t--depth;\r\n\r\n\t\t\t\t\t\tArray.prototype.push.apply(stack, next);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult.unshift(next);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn result.concat(stack);\r\n\t\t\t},\r\n\t\t\twritable: true\r\n\t\t},\r\n\t\tflatMap: {\r\n\t\t\tconfigurable: true,\r\n\t\t\tvalue: function flatMap(callback) {\r\n\t\t\t\treturn Array.prototype.map.apply(this, arguments).flat();\r\n\t\t\t},\r\n\t\t\twritable: true\r\n\t\t}\r\n\t});\r\n}\r\n\r\n// CONSTANTS\r\nObject.defineProperty(sj, 'SERVER_URL', {value: `http://localhost:3000`});\r\nObject.defineProperty(sj, 'API_URL', {value: `${sj.SERVER_URL}/api`});\r\nObject.defineProperty(sj, 'JSON_HEADER', {value: Object.freeze({\r\n\t'Accept': 'application/json',\r\n\t'Content-Type': 'application/json',\r\n})});\r\nObject.defineProperty(sj, 'URL_HEADER', {value: Object.freeze({\r\n\t'Accept': 'application/json',\r\n\t'Content-Type': 'application/x-www-form-urlencoded',\r\n})});\r\n\r\n\r\n//C used to indicate a specific server error\r\nsj.resolveActions = {\r\n\tspotifyAuth: 'spotify auth',\r\n};\r\n\r\n\r\n//             \r\n//           \r\n//                        \r\n//                          \r\n//                    \r\n//                      \r\n\r\n//C these don't reference any sj.Bases\r\n\r\n// TESTING\r\nsj.test = async function(tests, origin) {\r\n\tlet failCount = 0;\r\n\ttests.forEach((test, i) => {\r\n\t\tif (!test[1]) {\r\n\t\t\tconsole.error(`${origin} - test failed: ${test[0]}`);\r\n\t\t\tfailCount++;\r\n\t\t}\r\n\t});\r\n\r\n\tif (failCount === 0) {\r\n\t\tconsole.log(`%c${origin} - all tests passed`, 'background-color: #d0efd8');\r\n\t\treturn true;\r\n\t} else return false;\r\n};\r\nsj.performance = function (iterations, fs) {\r\n\tfs.forEach((f, index) => {\r\n\t\tconsole.time(`Function ${index} Start`);\r\n\t\tfor(let i = 0; i < iterations; i++) {\r\n\t\t\tf();\r\n\t\t}\r\n\t\tconsole.timeEnd(`Function ${index} End`);\r\n\t});\r\n};\r\nsj.wait = async function (ms) {\r\n    //C used for basic waiting, //! should not be used if the callback needs to be canceled\r\n\treturn new Promise(resolve => {\r\n\t\tif (ms <= 2147483647) { //L maximum timeout length: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\r\n\t\t\tsj.setTimeout(() => {\r\n\t\t\t\tresolve(`finished waiting ${ms}ms`);\r\n\t\t\t}, ms);\r\n\t\t}\r\n\t});\r\n};\r\nsj.trace = function () {\r\n\ttry {\r\n\t\tthrow Error('');\r\n\t} catch (e) {\r\n\t\t//TODO figure out how to properly display newlines as strings inside objects\r\n\r\n\t\t//C get stack\r\n\t\tconst stackTrace0 = e.stack;\r\n\t\t//C 'file:///' is removed (so that the URIs are clickable in node)\r\n\t\tconst stackTrace1 = sj.stringReplaceAll(stackTrace0, 'file:///', '');\r\n\t\t//C remove leading 'Error\\n    ', to reduce confusion because trace isn't an error\r\n\t\tconst stackTrace2 = sj.stringReplaceAll(stackTrace1, 'Error\\n', '');\r\n\t\t//C removes any line with Object.sj.trace\r\n\r\n\t\tlet ignore = [\r\n\t\t\t'Object.sj.trace',\r\n\t\t\t'new Base',\r\n\t\t\t'new Error',\r\n\t\t\t'Object.sj.catchUnexpected',\r\n\t\t\t'Object.sj.propagate',\r\n\t\t\t'sj.Error.announce',\r\n\t\t];\r\n\t\tignore = sj.stringReplaceAll(ignore.join('|'), '.', '\\.');\r\n\t\tconst exp = new RegExp(`(?:(?:\\\\n|\\n|\\r|$)* *at(?: |\\\\n|\\n|\\r|$))(?:${ignore})(?:.+?(?=\\\\n|\\n|\\r|$))`, 'g');\r\n\t\tconst stackTrace3 = sj.stringReplaceAll(stackTrace2, exp, '');\r\n\r\n\t\treturn stackTrace0;\r\n\t}\r\n};\r\nsj.image = function (value) {\r\n\tif (typeof value === null || typeof value !== 'object') return value;\r\n\treturn JSON.parse(JSON.stringify(sj.deepClone(value)));\r\n};\r\n\r\n// TYPE\r\nsj.isSubclass = function (a, b) {\r\n\tif (typeof a !== 'function' || typeof b !== 'function') return false;\r\n\telse return (a.prototype instanceof b);\r\n};\r\n\r\n// FORMAT\r\nsj.msFormat = function (ms) {\r\n\t// extract\r\n\tvar minutes = Math.floor(ms / 60000);\r\n\tvar seconds = Math.ceil(ms % 60000);\r\n\r\n\t// format\r\n\tseconds = ('0' + seconds).slice(-2);\r\n\r\n\t// returns ...0:00 format rounded up to the nearest second\r\n\treturn minutes + ':' + seconds;\r\n};\r\nsj.stringReplaceAll = function(input, search, replace) {\r\n\treturn input.split(search).join(replace);\r\n};\r\nsj.capFirst = function(string) {\r\n\treturn string.charAt(0).toUpperCase() + string.slice(1);\r\n};\r\nsj.clamp = function (input, min, max) {\r\n\tif (min > max) throw 'sj.clamp() min argument cannot be greater than max argument';\r\n\tif (input < min) return min;\r\n\telse if (max < input) return max;\r\n\telse return input;\r\n};\r\nsj.escapeRegExp = function (string) {\r\n\t//L from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\r\n\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n};\r\n\r\n// HTTP\r\nsj.encodeProps = function (obj) {\r\n\t//! every value is encoded as a string, objects as [object Object] and arrays as comma delimited encoded values\r\n\treturn Object.keys(obj).map(key => {\r\n\t\treturn `${encodeURIComponent(key)}=${encodeURIComponent(obj[key])}`;\r\n\t}).join('&');\r\n};\r\nsj.decodeProps = function (encoded) {\r\n\t//! every value is decoded as a string\r\n\tlet pairs = encoded.split('&');\r\n\tlet obj = {};\r\n\tpairs.forEach(pair => {\r\n\t\tlet parts = pair.split('=');\r\n\t\tobj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\r\n\t});\r\n\treturn obj;\r\n};\r\nsj.encodeList = function (list) {\r\n\t//C return a string of uri encoded key-value pairs for each property of each item, their keys suffixed with '-[index]'\r\n\t//! not called automatically by sj.request() because its useful to see when a encodeList exists as it needs to be unpacked on the other end\r\n\tlet indexed = {};\r\n\tsj.any(list).forEach((obj, i) => {\r\n\t\tObject.keys(obj).forEach(key => {\r\n\t\t\tindexed[`${key}-${i}`] = obj[key];\r\n\t\t});\r\n\t});\r\n\treturn sj.encodeProps(indexed);\r\n};\r\nsj.decodeList = function (encoded) {\r\n\t//C decodes a list of encoded objects with '-i' suffixed property keys\r\n\t//! any key not matching the format will be discarded\r\n\tlet indexed = sj.decodeProps(encoded);\r\n\tlet list = [];\r\n\tlet indexedKeys = Object.keys(indexed);\r\n\tfor (let i = 0; i < indexedKeys.length; i++) {\r\n\t\t//C validate delimiter\r\n\t\tlet delimiterIndex = indexedKeys[i].lastIndexOf('-');\r\n\t\tif (delimiterIndex < 0) {break}\r\n\r\n\t\t//C validate index\r\n\t\tlet objIndex = parseInt(indexedKeys[i].slice(delimiterIndex + 1)); //C handles multiple digits & no digits properly\r\n\t\tif (!sj.isType(objIndex, 'integer')) {break}\r\n\r\n\t\t//C get the real key\r\n\t\tlet key = indexedKeys[i].slice(0, delimiterIndex);\r\n\r\n\t\tif (!sj.isType(list[objIndex], Object)) {\r\n\t\t\t//C if the obj doesn't exist yet, add it with the prop\r\n\t\t\tlist[objIndex] = {\r\n\t\t\t\t[key]: indexed[indexedKeys[i]],\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\t//C otherwise add the prop to the existing object\r\n\t\t\tlist[objIndex][key] = indexed[indexedKeys[i]];\r\n\t\t}\r\n\t}\r\n\treturn list;\r\n};\r\n\r\n// FILTER\r\nsj.shake = function (obj, properties) {\r\n\t//C returns a new object with only the desired properties\r\n\tlet s = (obj, properties) => {\r\n\t\tif (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\torigin: 'sj.shake()',\r\n\t\t\t\treason: 'first argument is not an object',\r\n\t\t\t\tcontent: obj,\r\n\t\t\t});\r\n\t\t}\r\n\t\tif (!Array.isArray(properties)) {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\torigin: 'sj.shake()',\r\n\t\t\t\treason: 'second argument is not an array',\r\n\t\t\t\tcontent: properties,\r\n\t\t\t});\r\n\t\t}\r\n\t\t/* //R properties can be symbols, or any variable in maps\r\n\t\t\tif (!properties.each(property => typeof property === 'string')) {\r\n\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\torigin: 'sj.shake()',\r\n\t\t\t\t\treason: \"second argument's items are not all strings\",\r\n\t\t\t\t\tcontent: properties,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t*/\r\n\r\n\t\tlet newObj = {};\r\n\t\tproperties.forEach(prop => {\r\n\t\t\tif (obj[prop] !== undefined) {\r\n\t\t\t\tnewObj[prop] = obj[prop];\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn newObj;\r\n\t}\r\n\r\n\t//C handle objects and arrays of objects\r\n\tif (Array.isArray(obj)) return obj.map(item => s(item, properties));\r\n\telse return s(obj, properties);\r\n};\r\nsj.shake.test = function () {\r\n\tsj.test([\r\n\t\t['simple', true === sj.deepMatch(sj.shake([{a: 'a', b: 'b'}, {a: 'a', c: 'c'}], ['a']), [{a: 'a'}, {a: 'a'}])],\r\n\t], 'sj.shake.test()');\r\n};\r\nsj.assignDefined = function (target, ...args) {\r\n\targs.forEach(arg => {\r\n\t\tObject.keys(arg).forEach(key => {\r\n\t\t\tif (arg[key] !== undefined) target[key] = arg[key];\r\n\t\t});\r\n\t});\r\n\treturn target;\r\n};\r\n\r\n// SORT\r\nsj.stableSort = function(list, compare) {\r\n\t//L https://stackoverflow.com/questions/1063007/how-to-sort-an-array-of-integers-correctly\r\n\t//L https://stackoverflow.com/questions/1129216/sort-array-of-objects-by-string-property-value-in-javascript\r\n\t//L https://medium.com/@fsufitch/is-javascript-array-sort-stable-46b90822543f\r\n\t\r\n\tlet defaultCompare = (a, b) => {\r\n\t\t//C low to high\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t//C set compare to passed function or default\r\n\tcompare = typeof compare === 'function' ? compare : defaultCompare;\r\n\r\n\t//C create new array with original index preserved\r\n\tlet frozen = list.map(function (item, index) {\r\n\t\treturn {value: item, index: index};\r\n\t}); \r\n\r\n\tlet stableCompare = function (a, b) {\r\n\t\tlet order = compare(a.value, b.value);\r\n\r\n\t\tif (order === 0) {\r\n\t\t\t//C if equal, sort based on their original order\r\n\t\t\treturn a.index - b.index;\r\n\t\t} else {\r\n\t\t\t//C sort normally\r\n\t\t\treturn order;\r\n\t\t}\r\n\t}\r\n\r\n\tfrozen.sort(stableCompare);\r\n\r\n\t//C feed sorted array back into original array\r\n\tfor (let i = 0; i < list.length; i++) {\r\n\t\tlist[i] = frozen[i].value;\r\n\t}\r\n\r\n\treturn list;\r\n};\r\nsj.dynamicSort = function(list, ascending, prop) {\r\n\t//C sorts a list in ascending or descending order by the numeric or string-converted value of its items or their properties if a prop is defined\r\n\r\n\t//C ascending will flip the list into descending if false\r\n\tif (ascending) {\r\n\t\tascending = 1;\r\n\t} else {\r\n\t\tascending = -1;\r\n\t}\r\n\r\n\tlet compare;\r\n\tif (sj.isType(prop, 'string')) {\r\n\t\t//C if prop is defined, compare props\r\n\t\tif (list.every(item => sj.isType(item[prop], 'number') || sj.isType(item[prop], 'boolean'))) {\r\n\t\t\t//C if values are numbers or boolean, do number compare\r\n\t\t\tcompare = function (a, b) {\r\n\t\t\t\treturn (a[prop] - b[prop]) * ascending;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t//C if values are strings, other, or mixed, do a string conversion and string compare\r\n\t\t\tcompare = function (a, b) {\r\n\t\t\t\t//C convert to strings\r\n\t\t\t\tlet as = a[prop] + '';\r\n\t\t\t\tlet bs = b[prop] + '';\r\n\r\n\t\t\t\t//C string compare\r\n\t\t\t\t//L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\r\n\t\t\t\treturn as.localeCompare(bs, 'en', {sensitivity: 'base'}) * ascending;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\t//C if no prop is defined, compare values\r\n\t\t//! this is the exact same as above, just without the property\r\n\t\tif (list.every(item => sj.isType(item, 'number') || sj.isType(item, 'boolean'))) {\r\n\t\t\tcompare = function (a, b) {\r\n\t\t\t\treturn (a - b) * ascending;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcompare = function (a, b) {\r\n\t\t\t\tlet as = a + '';\r\n\t\t\t\tlet bs = b + '';\r\n\t\t\t\treturn as.localeCompare(bs, 'en', {sensitivity: 'base'}) * ascending;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn sj.stableSort(list, compare);\r\n};\r\n\r\n// MISC\r\nsj.deepAccess = function (thing, ...args) {\r\n\tconst path = args.flat();\r\n\t//C accesses nested properties of any variable type\r\n\t//C prevents errors from being thrown on property access of undefined or null, instead returns undefined\r\n\treturn path.reduce((accumulator, key) => {\r\n\t\t//C only undefined and null will throw errors for property access\r\n\t\tif (accumulator === undefined || accumulator === null) return undefined;\r\n\t\telse return accumulator[key];\r\n\t}, thing);\r\n};\r\nsj.deepClone = function (...args) {\r\n\t//C deep clones objects (root & nested objects aren't the same reference)\r\n\t//C drops circular references and replaces with '[Circular]'\r\n\treturn fClone(...args);\r\n};\r\nsj.Deferred = class Deferred extends Promise {\r\n\t//C custom promise that can be resolved, rejected, and canceled outside it's resolver\r\n\t//G may be called without a resolver\r\n\t//TODO//? cancel-able promises might not be the best idea\r\n\tconstructor(executor = (resolve, reject) => {}) {\r\n\t\t//C closure is used here instead of instance variables because they cannot be defined before super is called (which requires such variables)\r\n\t\tconst closure = {\r\n\t\t\tpending: true, //! doesn't stop additional resolve/reject calls, they still reach the parent promise, just acts as a readable state\r\n\t\t\tcanceled: false,\r\n\t\t};\r\n\r\n\t\t//C intercept executor function\r\n\t\tsuper((resolve, reject) => {\r\n\t\t\tclosure.resolve = function (resolved) {\r\n\t\t\t\tif (!closure.canceled) {\r\n\t\t\t\t\tclosure.pending = false;\r\n\t\t\t\t\tresolve(resolved);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tclosure.reject = function (rejected) {\r\n\t\t\t\tif (!closure.canceled) {\r\n\t\t\t\t\tclosure.pending = false;\r\n\t\t\t\t\treject(rejected);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\treturn executor(resolve, reject);\r\n\t\t});\r\n\r\n\t\t//C instance .resolve() and .reject() functions will use the closure to fulfill the promise from outside it's executor\r\n\t\tthis.resolve = closure.resolve;\r\n\t\tthis.reject = closure.reject;\r\n\r\n\t\t//C prevents promise from being resolved or rejected in the future\r\n\t\tthis.cancel = function () {\r\n\t\t\tclosure.canceled = true;\r\n\t\t};\r\n\t\t//C rejects the result of the passed function on timeout\r\n\t\tthis.timeout = function (ms, onTimeout = () => 'Deferred promise timed out') {\r\n\t\t\tsj.wait(ms).then(() => {\r\n\t\t\t\t//! doesn't call onTimeout() if the promise is already fulfilled, to avoid side-effects\r\n\t\t\t\tif (closure.pending) closure.reject(onTimeout());\r\n\t\t\t});\r\n\t\t\treturn this;\r\n\t\t};\r\n\r\n\t\t//C allow read-only access of pending and canceled directly on the deferred promise\r\n\t\tObject.defineProperty(this, 'pending', {\r\n\t\t\tget() {\r\n\t\t\t\treturn closure.pending;\r\n\t\t\t},\r\n\t\t});\r\n\t\tObject.defineProperty(this, 'canceled', {\r\n\t\t\tget() {\r\n\t\t\t\treturn closure.canceled;\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n};\r\n\r\n\r\n//                      \r\n//                   \r\n//                              \r\n//                              \r\n//              \r\n//                 \r\n\r\n//C these reference sj.Bases, don't call these until classes are defined\r\n\r\nsj.setTimeout = function (f, delay, ...args) {\r\n\t//C allows the use of Infinity for setTimeout()\r\n\t//! this will be clamped to 2147483647\r\n\t//L https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values\r\n\t//L https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Maximum_delay_value\r\n\r\n\tif (delay > 2147483647) {\r\n\t\tdelay = 2147483647;\r\n\t\t// new sj.Warn({\r\n\t\t// \torigin: 'setTimeout()',\r\n\t\t// \tmessage: 'setTimeout delay clamped to 2147483647 (24.8) days',\r\n\t\t// });\r\n\t}\r\n\r\n\treturn setTimeout(f, delay, ...args);\r\n};\r\n\r\n\r\n// SESSION //C holds login, get, logout, etc. methods\r\nsj.session = {};\r\n\r\n// TYPE\r\nsj.isType = function (input, type) {\r\n\t//C matches 'input' type or super-type to 'type' value or string representation or builtin object\r\n\t//!//! will not match arrays to Object\r\n\t//! will not match typeof input to typeof type, unless their exact values match - don't rely on this\r\n\t//R this intentional because it would be difficult to separate string identifiers from typeof 'anyString'\r\n\r\n\t//TODO also go back and fix the sj validation class of number, int, floats with this too\r\n\t//TODO see if this can be even more cleanly structured\r\n\t//TODO consider allowing the user of builtin objects\r\n\t//TODO make a list of reserved strings as identifiers (problem is for using a variable as the type to compare to, if it lands on any of these reserved words it wont match typeof type but the reserved meaning) //? actually I dont think this is needed because 'typeof type' is never used, type is only matching by value or its identifier\r\n\t\r\n\t/*\t//R\r\n\t\tcreated new typeOf function - there are two use cases: (minimal, similar to typeof keyword but fixes null & NaN) (extended, fleshes out sj.Base types etc.), both are probably needed but they cant exist at the same time - instead do something like isType(input, 'type') which can then be used to check many-to-one matches unlike a string comparison (x === 'y'), this will distance this function from typeof (which is a good thing)\r\n\t*/\r\n\t\r\n\r\n\t// value\r\n\tif (input === type) { //!//TODO this will cause issues with ('object', 'object') and inconsistencies like true === (sj.Entity, sj.Entity) vs false == (sj.Track, sj.Entity)\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\t\r\n\t// instanceof\r\n\tif (typeof type === 'function' && input instanceof type && !Array.isArray(input)) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// no sub-types\r\n\t//C these early return false to skip more expensive checks below\r\n\tif (input === undefined) {\r\n\t\t//! won't catch undeclared variables because they cannot be passed to functions without throwing a reference error\r\n\t\treturn type === undefined || type === 'undefined';\r\n\t}\r\n\tif (input === null) {\r\n\t\treturn type === null || type === 'null';\r\n\t}\r\n\tif (Array.isArray(input)) {\r\n\t\treturn type === Array || type === 'array';\r\n\t}\r\n\tlet t = typeof input; //! typeof fixes must go above this (null = 'object', array = 'object')\r\n\tif (t === 'boolean') {\r\n\t\treturn type === Boolean || type === 'boolean';\r\n\t}\r\n\tif (t === 'string') {\r\n\t\treturn type === String || type === 'string';\r\n\t}\r\n\r\n\t// sub-types\r\n\tif (t === type) {\r\n\t\treturn true;\r\n\t}\r\n\tif (t === 'object') {\r\n\t\tif (type === Object || type === 'object') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// sj.Base & sub-types\r\n\t\t//R this implementation removes the need for a custom object list, because if everything extends sj.Base, everything can also be compared as an instanceof sj.Base - keeping a list of string names (to reduce the need for building an object) wont work in the long run because inheritance cant be checked that way\r\n\t\tlet tempInput = input;\r\n\t\tlet tempType = type;\r\n\t\r\n\t\tif ((input instanceof sj.Base || (typeof input.constructorName === 'string' && (() => { \r\n\t\t\t//C input or input.constructorName is an instance of a constructible\r\n\t\t\tlet Target = sj[input.constructorName];\r\n\t\t\tif (typeof Target === 'function') {\r\n\t\t\t\ttempInput = new Target({log: false});\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t})())) && (typeof type === 'function' || (typeof type === 'string' && (() => {\r\n\t\t\t//C and type is constructible\r\n\t\t\tlet Target = sj[type];\r\n\t\t\tif (typeof Target === 'function') {\r\n\t\t\t\ttempType = Target;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t})()))) {\r\n\t\t\tif (tempInput instanceof tempType) { //C catch [input instance] instanceof [type constructible]\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (t === 'number') {\r\n\t\t//C Infinity is a number\r\n\r\n\t\tif (type === Number || type === 'number') {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// NaN\r\n\t\tif (Number.isNaN(input) && (Number.isNaN(type) || type === 'NaN' || type === 'nan')) {\r\n\t\t\t//! isNaN() and Number.isNaN() are slightly different: //L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// integer\r\n\t\tif (Number.isInteger(input) && (type === 'integer' || type === 'int')) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// float\r\n\t\tif (!Number.isInteger(input) && (type === 'float')) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\nsj.isEmpty = function (input) {\r\n\t//C null, undefined, and whitespace-only strings are 'empty' //! also objects and arrays\r\n\treturn !(\r\n\t\tsj.isType(input, 'boolean') || \r\n        sj.isType(input, 'number') || \r\n        //C check for empty and whitespace strings and string conversions of null and undefined\r\n        //TODO //! this will cause issues if a user inputs any combination of these values, ban them at the user input step\r\n        (sj.isType(input, 'string') && input.trim() !== '' && input.trim() !== 'null' && input.trim() !== 'undefined') ||\r\n        (sj.isType(input, 'object') && Object.keys(input).length > 0) ||\r\n        (sj.isType(input, 'array') && input.length > 0)\r\n\t);\r\n};\r\n//TODO consider using Object.is() (where +0 !== -0 and NaN === NaN) //L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\nsj.deepMatch = function (a, b, {\r\n\tdeep = true, \r\n\tdepth = 10, \r\n\tmatchIfTooDeep = false, \r\n\tmatchIfSubset = false, //C matches objects and arrays if a is a subset of b\r\n\tmatchOrder = true,\r\n\tlogDifference = false, //C logs first difference found if not matching\r\n} = {\r\n\tdeep: true, \r\n\tdepth: 10, \r\n\tmatchIfTooDeep: false, \r\n\tmatchIfSubset: false, \r\n\tmatchOrder: true,\r\n\tlogDifference: false,\r\n}) {\r\n\tif (depth <= 0) return matchIfTooDeep;\r\n\r\n\tif (a === b) return true; // primitives & references\r\n\tif (sj.isType(a, NaN) && sj.isType(b, NaN)) return true; // NaN\r\n\r\n\tif (deep) {\r\n\t\tlet matchDeeper = function (a, b) {\r\n\t\t\treturn sj.deepMatch(a, b, {deep, depth: depth-1, matchIfTooDeep, matchIfSubset, matchOrder});\r\n\t\t};\r\n\r\n\t\tif (sj.isType(a, Object) && sj.isType(b, Object)) { // objects\r\n\t\t\tlet matches = true;\r\n\t\t\tObject.keys(a).forEach(key => { //C match all keys of a to the same keys in b\r\n\t\t\t\tif (!matchDeeper(a[key], b[key])) {\r\n\t\t\t\t\tmatches = false;\r\n\t\t\t\t\tif (logDifference) console.log(`deepMatch property difference - ${key}: ${a[key]}, ${b[key]}`);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif (!matchIfSubset) {\r\n\t\t\t\tObject.keys(b).forEach(key => { //C match all keys of b to the same keys in a //TODO optimize here\r\n\t\t\t\t\tif (!matchDeeper(a[key], b[key])) {\r\n\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\tif (logDifference) console.log(`deepMatch property difference - ${key}: ${a[key]}, ${b[key]}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn matches;\r\n\t\t}\r\n\t\tif (sj.isType(a, Array) && sj.isType(b, Array)) { // arrays\r\n\t\t\tlet matches = true;\r\n\t\t\ta.forEach((inA, i) => {\r\n\t\t\t\tif (matchOrder) {\r\n\t\t\t\t\tif (!matchDeeper(a[i], b[i])) {\r\n\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\tif (logDifference) console.log(`deepMatch index difference - ${i}: ${a[i]}, ${b[i]}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { //C match any inB to current inA\r\n\t\t\t\t\tif (!b.some(inB => matchDeeper(inA, inB))) {\r\n\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\tif (logDifference) console.log(`deepMatch extra item in b - ${inB}`);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif (!matchIfSubset) {\r\n\t\t\t\tb.forEach((inB, i) => {\r\n\t\t\t\t\tif (matchOrder) {\r\n\t\t\t\t\t\tif (!matchDeeper(a[i], b[i])) {\r\n\t\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\t\tif (logDifference) console.log(`deepMatch index difference - ${i}: ${a[i]}, ${b[i]}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (!a.some(inA => matchDeeper(inA, inB))) {\r\n\t\t\t\t\t\t\tmatches = false;\r\n\t\t\t\t\t\t\tif (logDifference) console.log(`deepMatch extra item in a - ${inA}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\treturn matches;\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n};\r\nsj.deepMatch.test = function () {\r\n\tlet oA = {\r\n\t\ta: 'a',\r\n\t\tb: 'b',\r\n\t};\r\n\tlet oB = {\r\n\t\ta: 'a',\r\n\t\tb: 'b',\r\n\t};\r\n\tlet oC = {\r\n\t\ta: 'a',\r\n\t\tb: 'b',\r\n\t\tc: 'c',\r\n\t};\r\n\tlet oD = {\r\n\t\ta: 'a',\r\n\t\tb: 'not b',\r\n\t};\r\n\r\n\tlet aA = ['a', 'b'];\r\n\tlet aB = ['a', 'b'];\r\n\tlet aC = ['a', 'b', 'c'];\r\n\tlet aD = ['a', 'not b'];\r\n\tlet aE = ['a', 'c', 'b'];\r\n\r\n\tlet nA = {\r\n\t\ta: {\r\n\t\t\ta: {\r\n\t\t\t\ta: {\r\n\t\t\t\t\ta: 'a',\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\tlet nB = {\r\n\t\ta: {\r\n\t\t\ta: {\r\n\t\t\t\ta: {\r\n\t\t\t\t\ta: 'a',\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t//C aF is subset of aG at first level, but then aG is a subset of aF at second level, this should fail matchIfSubset\r\n\tlet aF = [\r\n\t\t{\r\n\t\t\ta: 'a',\r\n\t\t\tb: 'b',\r\n\t\t},\r\n\t];\r\n\tlet aG = [\r\n\t\t{\r\n\t\t\ta: 'a',\r\n\t\t},\r\n\t\t{\r\n\t\t\tb: 'b',\r\n\t\t},\r\n\t];\r\n\r\n\tsj.test([\r\n\t\t['match positive number', \t\ttrue === sj.deepMatch(1, 1)],\r\n\t\t['match zero', \t\t\t\t\ttrue === sj.deepMatch(0, 0)],\r\n\t\t['match negative number', \t\ttrue === sj.deepMatch(-1, -1)],\r\n\t\t['match infinity', \t\t\t\ttrue === sj.deepMatch(Infinity, Infinity)],\r\n\t\t['match negative infinity', \ttrue === sj.deepMatch(-Infinity, -Infinity)],\r\n\t\t['match NaN', \t\t\t\t\ttrue === sj.deepMatch(NaN, NaN)],\r\n\t\t['mismatch positive number', \tfalse === sj.deepMatch(4, 3193)],\r\n\t\t['mismatch positive negative', \tfalse === sj.deepMatch(-3, 0)],\r\n\t\t['mismatch infinity, number', \tfalse === sj.deepMatch(Infinity, 2345678909875498765456789)],\r\n\t\t['mismatch infinity, -infinity',false === sj.deepMatch(Infinity, -Infinity)],\r\n\t\t['mismatch NaN, zero', \t\t\tfalse === sj.deepMatch(NaN, 0)],\r\n\t\t['match true', \t\t\t\t\ttrue === sj.deepMatch(true, true)],\r\n\t\t['match false', \t\t\t\ttrue === sj.deepMatch(false, false)],\r\n\t\t['mismatch true, false', \t\tfalse === sj.deepMatch(true, false)],\r\n\t\t['match string', \t\t\t\ttrue === sj.deepMatch('test', 'test')],\r\n\t\t['match empty', \t\t\t\ttrue === sj.deepMatch('', '')],\r\n\t\t['match \"undefined\"', \t\t\ttrue === sj.deepMatch('undefined', 'undefined')],\r\n\t\t['match \"null\"', \t\t\t\ttrue === sj.deepMatch('null', 'null')],\r\n\t\t['mismatch string', \t\t\tfalse === sj.deepMatch('string', 'test')],\r\n\t\t['mismatch empty and filled', \tfalse === sj.deepMatch('', 'test')],\r\n\t\t['match object reference', \t\ttrue === sj.deepMatch(oA, oA)],\r\n\t\t['match object items', \t\t\ttrue === sj.deepMatch(oA, oB)],\r\n\t\t['match object subset', \t\ttrue === sj.deepMatch(oA, oC, { matchIfSubset: true})],\r\n\t\t['mismatch object not deep', \tfalse === sj.deepMatch(oA, oB, {deep: false})],\r\n\t\t['mismatch object, not subset', false === sj.deepMatch(oA, oC)],\r\n\t\t['mismatch object props', \t\tfalse === sj.deepMatch(oA, oD)],\r\n\t\t['match array reference', \t\ttrue === sj.deepMatch(aA, aA)],\r\n\t\t['match array items', \t\t\ttrue === sj.deepMatch(aA, aB)],\r\n\t\t['match array subset', \t\t\ttrue === sj.deepMatch(aA, aC, {matchIfSubset: true})],\r\n\t\t['match array, not order', \t\ttrue === sj.deepMatch(aC, aE, {matchOrder: false})],\r\n\t\t['mismatch array, not deep', \tfalse === sj.deepMatch(aA, aB, {deep: false})],\r\n\t\t['mismatch array, not subset', \tfalse === sj.deepMatch(aA, aC)],\r\n\t\t['mismatch array items', \t\tfalse === sj.deepMatch(aA, aD)],\r\n\t\t['mismatch array, order', \t\tfalse === sj.deepMatch(aC, aE)],\r\n\t\t['mismatch object, array', \t\tfalse === sj.deepMatch({}, [])],\r\n\t\t['match nested', \t\t\t\ttrue === sj.deepMatch(nA, nB)],\r\n\t\t['match nested if too deep', \ttrue === sj.deepMatch(nA, nB, {depth: 2, matchIfTooDeep: true})],\r\n\t\t['mismatch nested if too deep', false === sj.deepMatch(nA, nB, {depth: 2})],\r\n\t\t['mismatch subset switch',\t\tfalse === sj.deepMatch(aF, aG, {matchIfSubset: true})],\r\n\t], 'deepMatch');\r\n};\r\n\r\n// ERROR\r\nsj.catchUnexpected = function (input) {\r\n\t//C determines type of input, creates, announces, and returns a proper sj.Error object\r\n\t//C use in the final Promise.catch() to handle any unexpected variables or errors that haven't been caught yet\r\n\t\r\n\tvar error = new sj.Error({\r\n\t\tlog: false,\r\n\t\torigin: 'sj.catchUnexpected()',\r\n\t\tmessage: 'an unexpected error ocurred',\r\n\t\tcontent: input,\r\n\t});\r\n\r\n\tif (sj.isType(input, null)) {\r\n\t\terror.reason = 'unexpected null';\r\n\t} else if (sj.isType(input, Object)) {\r\n\t\tif (input instanceof Error) {\r\n\t\t\t//C this is going to catch the majority of unexpected inputs\r\n\r\n\t\t\t//! JSON.stringify() does not work on native Error objects as they have no enumerable properties therefore these cannot be passed between client & server,so when catching a native Error object properly convert it to a string with Error.toString() then save that in reason\r\n\t\t\t//L https://stackoverflow.com/questions/18391212/is-it-not-possible-to-stringify-an-error-using-json-stringify\r\n\t\t\terror.reason = input.toString();\r\n\r\n\t\t\t//C replace trace with actual trace (which has clickable URIs)\r\n\t\t\terror.trace = sj.stringReplaceAll(input.stack, 'file:///', '');\r\n\t\t} else if (sj.isType(input, sj.Base)) {\r\n\t\t\terror.reason = `unexpected ${input.constructorName}`;\r\n\t\t} else {\r\n\t\t\terror.reason = 'unexpected object';\r\n\t\t}\r\n\t} else {\r\n\t\terror.reason = `unexpected ${typeof input}`;\r\n\t}\r\n\r\n\terror.announce();\r\n\treturn error;\r\n};\r\nsj.propagate = function (input, overwrite) {\r\n\t//C wraps bare data caught by sj.catchUnexpected(), optionally overwrites properties\r\n\tif (!sj.isType(input, sj.Error)) { //C wrap any non-sj errors, let sj.Errors flow through\r\n\t\tinput = sj.catchUnexpected(input);\r\n\t}\r\n\tif (sj.isType(overwrite, Object)) { //C overwrite properties (for example making a more specific message)\r\n\t\tObject.assign(input, overwrite);\r\n\t\t//OLD this would recreate the trace, dont want to do this input = new input.constructor({...input, log: false, ...overwrite}); //C re-stuff, but don't announce again\r\n\t}\r\n\tthrow input;\r\n\r\n\t//TODO //? why not just use Object.assign(input) instead?\r\n\t//TODO better yet, why not just use a spread operator at the top?\r\n};\r\nsj.andResolve = function (rejected) {\r\n\t//C resolves/returns any errors thrown by sj.propagate()\r\n\t//G someAsyncFunction().catch(sj.andResolve);\r\n\ttry {\r\n\t\treturn sj.propagate(rejected);\r\n\t} catch (e) {\r\n\t\treturn e;\r\n\t}\r\n};\r\n\r\n// PROMISE\r\nsj.asyncForEach = async function (list, callback) {\r\n\t//C executes an async function for each item in an array, throws entire result list if any of it's items were thrown\r\n\t//L this helped: https://stackoverflow.com/questions/31424561/wait-until-all-es6-promises-complete-even-rejected-promises\r\n\t\r\n\t\r\n\r\n\t//C list is shallow copied because list could also be an array-like object\r\n\t//L https://stackoverflow.com/questions/31084619/map-a-javascript-es6-map\r\n\tlet tempList = [...list];\r\n\tlet results = await Promise.all(tempList.map(async (item, index, self) => callback(item, index, self).then(resolved => {\r\n\t\treturn {\r\n\t\t\tresolved: true,\r\n\t\t\tcontent: resolved,\r\n\t\t}\r\n\t}, rejected => {\r\n\t\t//C temporarily resolve rejections in a pack so that every item will be processed\r\n\t\treturn {\r\n\t\t\tresolved: false,\r\n\t\t\tcontent: sj.propagate(rejected),\r\n\t\t}\r\n\t})));\r\n\r\n\t//C while references are fine, primitives need to be given back to the original list\r\n\tfor(let i = 0; i < list.length; i++) {\r\n\t\tlist[i] = tempList[i];\r\n\t}\r\n\r\n\t//C check if any rejected\r\n\tlet allResolved = results.every(item => item.resolved);\r\n\t//C un-pack\r\n\tresults = results.map(item => item.content); \r\n\r\n\tif (allResolved) {\r\n\t\treturn results;\r\n\t} else {\r\n\t\tthrow results;\r\n\t}\r\n};\r\n\r\n// FORMAT\r\nsj.one = function (a) {\r\n\t//C unwraps the first item of an array where one item is expected\r\n\tif (!sj.isType(a, Array)) {\r\n\t\treturn a;\r\n\t} else if (a.length === 1) {\r\n\t\treturn a[0];\r\n\t} else if (a.length >= 2) {\r\n\t\t//TODO make a warning object / handler?\r\n\t\tconsole.warn('sj.one() pulled a single value out of an array with many');\r\n\t\treturn a[0];\r\n\t} else if (a.length === 0) {\r\n\t\t//! this does not return undefined because we are 'expecting' one value (//TODO though this may be changed later to return undefined)\r\n\t\tthrow new sj.Error({\r\n\t\t\tlog: true,\r\n\t\t\torigin: 'sj.one()',\r\n\t\t\tcode: 404,\r\n\t\t\tmessage: 'no data found',\r\n\t\t\treason: 'array has no values, expected one',\r\n\t\t\tcontent: a,\r\n\t\t});\r\n\t}\r\n};\r\nsj.any = function (o) {\r\n\t//C wraps a value in an array if not already inside one\r\n\treturn sj.isType(o, Array) ? o : [o];\r\n};\r\nsj.content = function (resolved) {\r\n\t//C shorter syntax for immediately returning the content property of a resolved object in a promise chain\r\n\treturn resolved.content;\r\n};\r\n\r\n// RECURSION\r\n//TODO consider using Promise.race //L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\r\nsj.recursiveSyncTime = async function (n, loopCondition, f, ...args) {\r\n\t//L rest parameters\thttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\r\n\tlet timestamp = Date.now();\r\n\tfunction loop() {\r\n\t\tif (Date.now() > timestamp + n) {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'recursiveSyncTime()',\r\n\t\t\t\treason: 'recursive function timed out',\r\n\t\t\t\tcontent: f,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet result = f(...args);\r\n\t\tif (loopCondition(result)) {\r\n\t\t\tresult = loop();\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\treturn loop();\r\n};\r\nsj.recursiveSyncCount = async function (n, loopCondition, f, ...args) {\r\n\tlet count = 0;\r\n\tfunction loop(count) {\r\n\t\tif (count >= n) {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'recursiveSyncCount',\r\n\t\t\t\treason: 'recursive function counted out',\r\n\t\t\t\tcontent: f,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet result = f(...args);\r\n\t\tif (loopCondition(result)) {\r\n\t\t\tresult = loop(++count);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\treturn loop(count);\r\n};\r\nsj.recursiveAsyncTime = async function (n, loopCondition, f, ...args) {\r\n\tlet timestamp = Date.now();\r\n\tasync function loop() {\r\n\t\tif (Date.now() > timestamp + n) {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'recursiveAsyncTime()',\r\n\t\t\t\treason: 'recursive function timed out',\r\n\t\t\t\tcontent: f,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet result = await f(...args);\r\n\t\tif (loopCondition(result)) {\r\n\t\t\tresult = await loop();\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t};\r\n\treturn await loop();\r\n};\r\nsj.recursiveAsyncCount = async function (n, loopCondition, f, ...args) {\r\n\tlet count = 0;\r\n\tasync function loop(count) {\r\n\t\tif (count >= n) {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'recursiveAsyncCount()',\r\n\t\t\t\treason: 'recursive function counted out',\r\n\t\t\t\tcontent: f,\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet result = await f(...args);\r\n\t\tif (loopCondition(result)) {\r\n\t\t\tresult = await loop(++count);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\treturn await loop(count);\r\n};\r\n\r\n//C uses recursiveAsyncTime to periodically check a condition\r\nsj.waitForCondition = async function ({\r\n\tinterval = 100,\r\n\tscaling = 1,\r\n\tdelay = 0,\r\n\ttimeout = 2000,\r\n\tcondition = () => false,\r\n}) {\r\n\tawait sj.recursiveAsyncTime(timeout, () => !condition(), async o => {\r\n\t\tawait sj.wait(o.time);\r\n\t\to.time = o.time * scaling;\r\n\t\treturn;\r\n\t}, {time: interval + delay});\r\n};\r\n\r\n// HTTP\r\nsj.rebuild = function (input, strict) {\r\n\t//C turns a bare object back into its custom class if it has a valid constructorName property\r\n\r\n\tif (sj.isType(input, String)) { //C parse if string\r\n\t\ttry {\r\n\t\t\tinput = JSON.parse(input);\r\n\t\t} catch (e) {\r\n\t\t\treturn new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'sj.rebuild()',\r\n\t\t\t\tmessage: 'failed to recreate object',\r\n\t\t\t\treason: e,\r\n\t\t\t\tcontent: input,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\tif (!sj.isType(input, Object)) { //C throw if not object\r\n\t\treturn new sj.Error({\r\n\t\t\tlog: true,\r\n\t\t\torigin: 'sj.rebuild()',\r\n\t\t\tmessage: 'failed to recreate object',\r\n\t\t\treason: 'data is not an object',\r\n\t\t\tcontent: input,\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tlet rebuilt = input;\r\n\tif (sj.isType(input, sj.Base)) { //C rebuild if possible\r\n\t\trebuilt = new sj[input.constructorName](input);\r\n\t} else if (strict) { //C throw if not possible and strict\r\n\t\treturn new sj.Error({\r\n\t\t\tlog: true,\r\n\t\t\torigin: 'sj.rebuild()',\r\n\t\t\tmessage: 'failed to recreate object',\r\n\t\t\treason: 'object is not a valid sj.Base',\r\n\t\t\tcontent: input,\r\n\t\t});\r\n\t}\r\n\r\n\treturn rebuilt;\r\n};\r\nsj.request = async function (method, url, body, headers = sj.JSON_HEADER) {\r\n\t/* //! use UPPERCASE HTTP methods...\r\n\t\t//! ...because in the fetch api 'PATCH' is case-sensitive where get, post, delete aren't\r\n\t\t//L its absurd, but apparently intentional: https://stackoverflow.com/questions/34666680/fetch-patch-request-is-not-allowed\r\n\t\t//L https://github.com/whatwg/fetch/issues/50\r\n\t\t//L https://github.com/github/fetch/pull/243\r\n\t*/\r\n\r\n\tlet options = {\r\n\t\tmethod,\r\n\t\theaders,\r\n\t\tbody,\r\n\t};\r\n\tif (method === 'GET') {\r\n\t\tif (sj.isType(body, Object)) {\r\n\t\t\turl += `?${sj.encodeProps(body)}`;\r\n\t\t}\r\n\t\tdelete options.body;\r\n\t} \r\n\tif (sj.isType(options.body, Object) || sj.isType(options.body, Array)) { //C stringify body\r\n\t\ttry {\r\n\t\t\toptions.body = JSON.stringify(sj.deepClone(options.body));\r\n\t\t} catch (e) {\r\n\t\t\t//C catch stringify error (should be a cyclic reference)\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\torigin: 'request()',\r\n\t\t\t\tmessage: 'could not send request',\r\n\t\t\t\treason: e.message,\r\n\t\t\t\tcontent: options.body,\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tlet result = await sj.fetch(url, options).catch(rejected => { //L fetch: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\r\n\t\t//C catch network error\r\n\t\t//L when fetch errors: https://www.tjvantoll.com/2015/09/13/fetch-and-errors/\r\n\t\t//TODO properly parse\r\n\t\tthrow sj.propagate(rejected);\r\n\t});\r\n\t\r\n\r\n\t//TODO sort out the codes and parsing below\r\n\r\n\t//C catch ok, no content code\r\n\tif (result.status === 204) {\r\n\t\treturn new sj.Success({\r\n\t\t\torigin: 'sj.request()',\r\n\t\t\tcode: '204',\r\n\t\t\tmessage: 'success',\r\n\t\t\treason: 'request successful, no content returned',\r\n\t\t});\r\n\t}\r\n\r\n\r\n\t//C parse via fetch .json()\r\n\t//L https://developer.mozilla.org/en-US/docs/Web/API/Body/json\r\n\tlet raw = await result.clone().text();\r\n\tlet parsedResult = await result.clone().json().catch(rejected => {\r\n\t\tthrow sj.propagate(rejected, {content: raw});\r\n\t});\r\n\r\n\t//C catch non-ok status codes\r\n\tif (!result.ok) {\r\n\t\t//TODO properly parse\r\n\t\tthrow sj.propagate(parsedResult);\r\n\t}\r\n\r\n\t//C rebuild and throw if error\r\n\tlet build = function (item) {\r\n\t\titem = sj.rebuild(item);\r\n\t\tif (sj.isType(item, sj.Error)) {\r\n\t\t\tthrow item;\r\n\t\t}\r\n\t\treturn item;\r\n\t}\r\n\tif (sj.isType(parsedResult, Array)) {\r\n\t\treturn await sj.asyncForEach(parsedResult, item => build(item));\r\n\t} else {\r\n\t\treturn build(parsedResult);\r\n\t}\r\n};\r\n\r\n// LIVE DATA\r\nsj.Subscriptions = function () {\r\n\t//C creates an array for each Entity type\r\n\tsj.Entity.children.forEach(child => {\r\n\t\tthis[child.table] = [];\r\n\t});\r\n};\r\n\r\n// RANDOM KEY GENERATION //TODO this is only public for testing\r\nsj.makeKey = function (length) {\r\n    //C use only characters allowed in URLs\r\n    let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\r\n    let key = '';\r\n    for (let i = 0; i < length; i++) {\r\n        key += characters.charAt(Math.floor(Math.random() * characters.length));\r\n    }\r\n    return key;\r\n};\r\nsj.addKey = async function (list, timeout) {\r\n    let pack = {};\r\n    let defaultTimeout = 300000; //C default 5 minutes\r\n\r\n    pack.key = await sj.recursiveSyncCount(100, (key) => {\r\n        let found = false;\r\n        for (let i = 0; i < list.length; i++) {\r\n            if (list[i].key === key) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        return found;\r\n    }, sj.makeKey, 10);\r\n\r\n    pack.timestamp = Date.now();\r\n    pack.timeout = pack.timestamp;\r\n    sj.isType(timeout, 'number') ? pack.timeout += timeout : pack.timeout += defaultTimeout;\r\n\r\n    list.push(pack);\r\n    return pack;\r\n};\r\nsj.checkKey = async function (list, key) {\r\n    //C checks a list for a key, will remove and return if found, will clean up timed-out keys\r\n    \r\n    for(let i = 0; i < list.length; i++) {\r\n        //C check if timed out\r\n        let fresh = list[i].timeout > Date.now() ? true : false;\r\n        \r\n        //C if the key is found and not timed out, take it out and return it\r\n        if (list[i].key === key && fresh) {\r\n            return list.splice(i, 1)[0];\r\n        }\r\n\r\n        //C remove timed-out keys //TODO check that this works\r\n        if (!fresh) {\r\n            list.splice(i, 1);\r\n        }\r\n    }\r\n\r\n    throw new sj.Error({\r\n        log: true,\r\n        origin: 'checkKey()',\r\n        message: 'request timeout, or just an invalid key',\r\n    });\r\n};\r\n\r\n\t\r\n//          \r\n//       \r\n//            \r\n//            \r\n//    \r\n//     \r\n\r\n/* //TODO\r\n\t//G wrapper objects vs bare return\r\n\t\tsimple functions should just return the bare result, for testing purposes these can also have guard clauses and throw a more descriptive sj.Error\r\n\t\tmore complex functions (async, error-able, client-server transfer) should wrap their result:\r\n\t\t\tsj.Success / sj.SuccessList\r\n\t\t\t\twraps empty content, arrays of other objects, misc content\r\n\t\t\t\tor is a descendant item object\r\n\t\t\tor a sj.Error / sj.ErrorList\r\n\t\t\t\twraps empty content, arrays of other objects with at least one error, non-sj errors\r\n\t\t\t\tor is a custom error\r\n\r\n\t\t//R\r\n\t\tclient-server transfer is the one place where the resolve/reject state of promises won't work - this is the big reason why wrappers are needed\r\n\t\teven though resolve and rejections don't need to be the same format, its still useful to have the ability influence resolved values with a success wrapper for say logging or debugging\r\n\r\n\treconsider the default values of class properties - semantics of undefined & null, error handling of placeholders '', [], {}, inequality of Symbol(), 'emptiness' sj.isEmpty()\r\n\r\n\tpossibly a cyclical reference preservation function between client and server that replaces a reference to self with 'self1' keyword and also can find lower-level cyclical references by recursively calling the function on each layer with memory for which layer its on\r\n\r\n*/\r\n\r\n//L functional classes: https://stackoverflow.com/questions/15192722/javascript-extending-class\r\n\r\n\r\n/* //R Thought Process\r\n\t//R Initially only static methods and variables I decided to define outside the class because static variables requires the use of a getter, which felt hacky.\r\n\t//R But when I needed to augment the constructor of a class I ran into problems, so I decided to define classes like this - with an anonymous function being called on a minimal class. It makes the location of instance methods, instance variables, static methods, and static variables more clear. It also makes augmenting (not extending) a class easier (specifically the defaults), this is important for divergent client and server classes.\r\n\t//R finally I found that I was repeating some parts of this anonymous function like const parent = Object.getPrototypeOf(this); and return this;, so I decided to make a factory function for all descendants of sj.Base, and a similar augmentation function, this was also done partly so that defaults, instanceMethods, and statics can be laid out with similar hierarchy.\r\n*/\r\n//C manually create sj.Base\r\n//TODO - consider changing all the constructorParts into functions (like static/prototypeProperties) that return an object to be assigned, (I think this may help with the defaults reference issue), but that also still can execute code. Maybe when this is done, then these parts can be brought up to the top level because they will now have their own closure context to process in\r\nsj.Base = class Base {\r\n\tconstructor(options) {\r\n\t\t//! defaults are retrieved in the function via the static this.constructor.defaults property\r\n\t\tthis.constructor.construct.call(this, options); \r\n\t}\r\n};\r\n(function () {\r\n\t//G use makeClass and augmentClass with assignment functions that can manually assign properties via this.x = 'x', and/or return an object that has those properties assigned (may use an arrow function to shorten the syntax). both work the same way, but the manual assignment has is able to do more - make getters, execute 'on create' functionality, create closures for extension, and delete properties (//! don't do this though)\r\n\t//TODO consider deep defaults\r\n\tthis.makeClass = function (name, parent, {\r\n\t\t//G may contain functions: beforeInitialize, afterInitialize; boolean: allowUnknown; and object: defaults\r\n\t\t//! anything in here (including stuff that shouldn't be) will overwrite staticProperties \r\n\t\tconstructorParts = parent => ({}),\r\n\t\t//G instance methods\r\n\t\tprototypeProperties = parent => ({}),\r\n\t\t//G static properties & methods\r\n\t\tstaticProperties = parent => ({}),\r\n\t}) {\r\n\t\t//C creates a descendant class of sj.Base with easily accessible properties for later augmentation, applies staticProperties, before/afterInitialize, allowUnknown, and defaults to static self and instanceMethods to instance prototype\r\n\t\r\n\r\n\t\t// VALIDATE\r\n\t\tif (!sj.isType(name, String)) throw 'sj.Base.makeClass() - cannot make class, name is not a string';\r\n\t\t//! don't convert sj.Base to this here, it will break ChildClass.makeClass({'X', sj.Base, {...}})\r\n\t\tif (!(parent === sj.Base || parent.prototype instanceof sj.Base)) throw 'sj.Base.makeClass() - cannot make class, parent is not of type sj.Base';\r\n\t\r\n\t\t//C dynamically create class using inferred function names\r\n\t\t//L https://stackoverflow.com/questions/33605775/es6-dynamic-class-names/33611096\\\r\n\t\t//G sj.Base descendants pass new static constructorParts to extend from their parent's constructorParts rather than having an extended constructor\r\n\t\t//C the allows sj.Base.construct() to only be called once, which simplifies their 'on create' functionality\r\n\t\tconst MadeClass = {[name]: class extends parent {\r\n\t\t\tconstructor(options) {\r\n\t\t\t\tsuper(options);\r\n\t\t\t}\r\n\t\t}}[name];\r\n\r\n\t\t// ASSIGN\r\n\t\t//C use .call to set 'this' as MadeClass, pass parent for ease of use and to avoid repeating Object.getPrototypeOf(this)\r\n\t\t//C undefined properties won't be passed, and parent's will be used when looked up\r\n\t\t//! ensure each part is only called once, as they may also have alternative assignment methods (such as on create functionality and getter/setter assignment)\r\n\r\n\t\t//! staticProperties is assigned before constructorParts so that constructorParts will take priority if there are collisions\r\n\t\tObject.assign(MadeClass, staticProperties.call(MadeClass, parent));\r\n\r\n\t\t/* //R thoughts on defaults\r\n\t\t\t//R my first thought was to have default values that are undefined to be undeclared as well, so that properties the properties won't show up and will be more useful when overwriting another\r\n\t\t\t//R I wanted to mimic this behavior with instance options - however, this would be inconsistent when using the spread operator, as it functions like Object.assign\r\n\t\t\t//R however I'm now realizing that this would be more consistent and clear\r\n\t\t\t//R I thought about doing three different 'defaults' objects, invisible (wont be declared if undefined, ie default undefined), normal, and 'fixed'(?), ones that cannot be changed by options\r\n\t\t\t//R but this doesn't seem right, for invisible: when making a new object I should really stay away from using the literal undefined value, and any spread operators used will still function as expected, for fixed, these can just be defaults as they are, because I really shouldn't be overwriting them with options anyways, and they can always be changed later anyways\r\n\t\t*/\r\n\t\tObject.assign(MadeClass, {\r\n\t\t\t//C constructorParts defaults\r\n\t\t\t//! these require empty defaults because of how construct() works - they are composed together rather than inheriting from the parent\r\n\t\t\tbeforeInitialize() {},\r\n\t\t\tafterInitialize() {},\r\n\t\t\tdefaults: {},\r\n\t\t\t//! allowUnknown DOES inherit from the parent and should not have a default to avoid overwriting the parent's true value with an undefined value defaulted to false\r\n\t\t}, constructorParts.call(MadeClass, parent));\r\n\r\n\t\t//C instance methods are assigned to the instance.prototype so that new methods aren't created for each instance\r\n\t\tObject.assign(MadeClass.prototype, prototypeProperties.call(MadeClass.prototype, parent));\r\n\t\t//? shouldn't the this reference be the parent.prototype?\r\n\t\r\n\r\n\t\treturn MadeClass;\r\n\t};\r\n\tthis.augmentClass = function ({\r\n\t\tconstructorParts = parent => ({}),\r\n\t\tprototypeProperties = parent => ({}),\r\n\t\tstaticProperties = parent => ({}),\r\n\t}) {\r\n\t\t//C add or overwrite existing properties with new ones\r\n\t\t//G to extend: store old property in a variable not attached to this (a closure) and then compose the new property with it\r\n\t\t//! when not just returning an object for assignment, ensure existing properties aren't being deleted, it goes against what this method should do\r\n\t\t//! make sure each part is ony called once (see makeClass)\r\n\r\n\t\tconst parent = Object.getPrototypeOf(this);\r\n\t\tObject.assign(this, staticProperties.call(this, parent));\r\n\r\n\t\t//C don't overwrite defaults, assign them too\r\n\t\tconst constructorPartsResult = constructorParts.call(this, parent);\r\n\t\tif (sj.isType(constructorPartsResult, Object)) { \r\n\t\t\t//! Object.assign can handle undefined, but destructuring can't which is why constructorPartsResult needs to be checked\r\n\t\t\tconst {defaults = {}, ...rest} = constructorPartsResult;\r\n\t\t\tObject.assign(this, rest);\r\n\t\t\tObject.assign(this.defaults, defaults);\r\n\t\t}\r\n\r\n\t\tObject.assign(this.prototype, prototypeProperties.call(this.prototype, parent.prototype));\r\n\t};\r\n\r\n\tthis.defaults = {\r\n\t\t// debug\r\n\t\tlog: false,\r\n\r\n\t\t// info\r\n\t\tcode: 200,\r\n\t\ttype: 'Ok',\r\n\t\torigin: '',\r\n\t\ttrace: '', //sj.trace(), //! this traces when the object is created, not where announce is called - this might have to be changed, this on create property could replace origin though\r\n\r\n\t\t// content\r\n\t\tmessage: '',\r\n\t\treason: '',\r\n\t\tcontent: {},\r\n\t};\r\n\tthis.allowUnknown = false;\r\n\tthis.beforeInitialize = function (accessory) {\r\n\t\t//C rebuild content if is of type sj.Base\r\n\t\t//!//G all classes are responsible for rebuilding their other properties if they are also sj.Base class instances\r\n\t\tif (sj.isType(accessory.options.content, sj.Base)) {\r\n\t\t\taccessory.options.content = sj.rebuild(accessory.options.content);\r\n\t\t} else if (sj.isType(accessory.options.content, Array)) {\r\n\t\t\taccessory.options.content.forEach((item, i, list) => {\r\n\t\t\t\tif (sj.isType(item, sj.Base)) list[i] = sj.rebuild(item);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\tthis.afterInitialize = function (accessory) {\r\n\t};\r\n\r\n\tthis.prototype.announce = function () {\r\n\t\t//R this replaces a need to log the result of functions and removes the intermediate steps need to do so (let result = new Object;, log;, return;)\r\n\t\tif (sj.isType(this, sj.Error)) {\r\n\t\t\tconsole.error(`  ${this.constructorName} ${this.origin} ${this.message} \\n`, this, `\\n  `);\r\n\t\t} else if (sj.isType(this, sj.Warn)) {\r\n\t\t\tconsole.warn(`W  ${this.constructorName} ${this.origin} ${this.message} \\n`, this, `\\n W `);\r\n\t\t} else {\r\n\t\t\tconsole.log(`  ${this.constructorName} ${this.origin} ${this.message}\\n${sj.trace()}`); //\r\n\t\t}\r\n\t};\r\n\r\n\tthis.construct = function (options = {}) {\r\n\t\tconst accessory = {options};\r\n\r\n\t\t//C get prototype chain\r\n\t\tconst chain = [this.constructor];\r\n\t\t//C push the prototype of the last item in the chain until sj.Base is reached\r\n\t\twhile(chain[chain.length-1] !== sj.Base) chain.push(Object.getPrototypeOf(chain[chain.length-1]));\r\n\t\t\r\n\t\t//C call ancestor's and own beforeInitialize() in descending order\r\n\t\tfor (let i = chain.length-1; i >= 0; i--) chain[i].beforeInitialize.call(this, accessory);\r\n\r\n\t\t//C store constructor.name on this instance as constructorName so that it can be stringified and rebuilt\r\n\t\tthis.constructorName = this.constructor.name; \r\n\r\n\t\t//C assign the ancestor's and own defaults in descending order\r\n\t\tconst extendedDefaults = {};\r\n\t\tfor (let i = chain.length-1; i >= 0; i--) Object.assign(extendedDefaults, chain[i].defaults);\r\n\r\n\t\tconst composed = {};\r\n\t\t//C assign all properties from options\r\n\t\tif (this.allowUnknown) Object.assign(composed, extendedDefaults, options); \r\n\t\t//C or only assign properties declared in defaults\r\n\t\telse Object.assign(composed, extendedDefaults, sj.shake(options, Object.keys(extendedDefaults))); \r\n\t\t//C then assign to instance non-undefined properties (so that anything that has the value undefined, will be undeclared)\r\n\t\tsj.assignDefined(this, composed); //? is this preferable to simply using sj.assignDefined in places where it's needed?\r\n\r\n\t\t//C call ancestor's and own afterInitialize in order\r\n\t\tfor (let i = chain.length-1; i >= 0; i--) chain[i].afterInitialize.call(this, accessory);\r\n\r\n\t\tif (this.log) this.announce();\r\n\t};\r\n}).call(sj.Base);\r\nsj.Base.test = async function () {\r\n\tlet calledConstructorParts \t\t= false;\r\n\tlet calledBeforeInitialize \t\t= false;\r\n\tlet calledAfterInitialize \t\t= false;\r\n\tlet calledPrototypeProperties \t= false;\r\n\tlet calledStaticProperties \t\t= false;\r\n\tlet calledExtraFunction\t\t\t= false;\r\n\r\n\r\n\tconst A = sj.Base.makeClass('A', sj.Base, {\r\n\t\t//C testing options functions and properties\r\n\t\tconstructorParts(parent) {\r\n\t\t\tcalledConstructorParts = true;\r\n\t\t\treturn {\r\n\t\t\t\tbeforeInitialize() {\r\n\t\t\t\t\tcalledBeforeInitialize = true;\r\n\t\t\t\t\tthis.beforeFoo = Symbol();\r\n\t\t\t\t},\r\n\t\t\t\tdefaults: {\r\n\t\t\t\t\tdefaultFoo: Symbol(),\r\n\t\t\t\t\tpassedFoo: 'passed as not default',\r\n\r\n\t\t\t\t\tundefinedFoo: undefined,\r\n\t\t\t\t\tundefinedOptionFoo: 'passed as undefined',\r\n\t\t\t\t\t// undeclaredFoo is not declared\r\n\t\t\t\t},\r\n\t\t\t\tafterInitialize() {\r\n\t\t\t\t\tcalledAfterInitialize = true;\r\n\t\t\t\t\tthis.afterFoo = Symbol();\r\n\t\t\t\t},\r\n\t\t\t};\r\n\t\t},\r\n\t\tprototypeProperties(parent) {\r\n\t\t\tcalledPrototypeProperties = true;\r\n\t\t\treturn {\r\n\t\t\t\tprototypeFoo: Symbol(),\r\n\t\t\t}\r\n\t\t},\r\n\t\tstaticProperties(parent) {\r\n\t\t\tcalledStaticProperties = true;\r\n\t\t\treturn {\r\n\t\t\t\tstaticFoo: Symbol(),\r\n\t\t\t};\r\n\t\t},\r\n\r\n\t\textraFunction() {\r\n\t\t\tcalledExtraFunction = true;\r\n\t\t},\r\n\t}); \r\n\tconst a = new A({passedFoo: Symbol(), undefinedOptionFoo: undefined});\r\n\tconst a2 = new A({passedFoo: Symbol()});\r\n\r\n\tconst AA = sj.Base.makeClass('AA', A, {\r\n\t\t//C testing property inheritance and extension\r\n\t\tconstructorParts: parent => ({\r\n\t\t\tbeforeInitialize() {\r\n\t\t\t\tthis.beforeFoo2 = Symbol();\r\n\t\t\t},\r\n\t\t\tdefaults: {\r\n\t\t\t\tdefaultFoo2: Symbol(),\r\n\t\t\t},\r\n\t\t\tafterInitialize() {\r\n\t\t\t\tthis.afterFoo2 = Symbol();\r\n\t\t\t},\r\n\t\t}),\r\n\t\tprototypeProperties: parent => ({\r\n\t\t\tprototypeFoo2: Symbol(),\r\n\t\t}),\r\n\t\tstaticProperties: parent => ({\r\n\t\t\tstaticFoo2: Symbol(),\r\n\t\t}),\r\n\t}); \r\n\tconst aa = new AA();\r\n\t\r\n\tconst AAA = sj.Base.makeClass('AAA', AA, {}); \r\n\tconst aaa = new AAA();\r\n\r\n\tconst AAB = sj.Base.makeClass('AAB', AA, {}); \r\n\tconst aab = new AAB();\r\n\r\n\tconst AB = sj.Base.makeClass('AB', A, {\r\n\t\t//C testing child overwrites\r\n\t\tconstructorParts: parent => ({\r\n\t\t\tbeforeInitialize() {\r\n\t\t\t\tthis.beforeFoo = Symbol();\r\n\t\t\t},\r\n\t\t\tdefaults: {\r\n\t\t\t\tdefaultFoo: Symbol(),\r\n\t\t\t},\r\n\t\t\tafterInitialize() {\r\n\t\t\t\tthis.afterFoo = Symbol();\r\n\t\t\t},\r\n\t\t}),\r\n\t\tprototypeProperties: parent => ({\r\n\t\t\tprototypeFoo: Symbol(),\r\n\t\t}),\r\n\t\tstaticProperties: parent => ({\r\n\t\t\tstaticFoo: Symbol(),\r\n\t\t}),\r\n\t}); \r\n\tconst ab = new AB();\r\n\t\t\r\n\tconst B = sj.Base.makeClass('B', sj.Base, {}); \r\n\tconst b = new B();\r\n\r\n\tconst BA = sj.Base.makeClass('BA', B, {}); \r\n\tconst ba = new BA();\r\n\r\n\tconst BB = sj.Base.makeClass('BB', B, {}); \r\n\tconst bb = new BB();\r\n\r\n\tconst C = sj.Base.makeClass('C', sj.Base, {\r\n\t\t//C testing augmented properties\r\n\t\tconstructorParts: parent => ({\r\n\t\t\tbeforeInitialize() {\r\n\t\t\t\tthis.beforeBar =  Symbol();\r\n\t\t\t},\r\n\t\t\tdefaults: {\r\n\t\t\t\tdefaultBar: Symbol(),\r\n\t\t\t},\r\n\t\t\tafterInitialize() {\r\n\t\t\t\tthis.afterBar =  Symbol();\r\n\t\t\t},\r\n\t\t}),\r\n\t\tprototypeProperties: parent => ({\r\n\t\t\tprototypeBar: Symbol(),\r\n\t\t}),\r\n\t\tstaticProperties: parent => ({\r\n\t\t\tstaticBar: Symbol(),\r\n\t\t}),\r\n\t});\r\n\tconst c = new C();\r\n\r\n\tC.augmentClass({\r\n\t\tconstructorParts: parent => ({\r\n\t\t\tbeforeInitialize() {\r\n\t\t\t\tthis.beforeBar =  Symbol();\r\n\t\t\t},\r\n\t\t\tdefaults: {\r\n\t\t\t\tdefaultBar: Symbol(),\r\n\t\t\t},\r\n\t\t\tafterInitialize() {\r\n\t\t\t\tthis.afterBar =  Symbol();\r\n\t\t\t},\r\n\t\t}),\r\n\t\tprototypeProperties: parent => ({\r\n\t\t\tprototypeBar: Symbol(),\r\n\t\t}),\r\n\t\tstaticProperties: parent => ({\r\n\t\t\tstaticBar: Symbol(),\r\n\t\t}),\r\n\t});\r\n\tconst c2 = new C();\r\n\r\n\r\n\tawait sj.test([\r\n\t\t// INHERITANCE\r\n\t\t['A prototype is sj.Base', \tObject.getPrototypeOf(A) === sj.Base],\r\n\t\t['AA prototype is A', \t\tObject.getPrototypeOf(AA) === A],\r\n\t\t['AAAA prototype is AA', \tObject.getPrototypeOf(AAA) === AA],\r\n\r\n\t\t['a isType sj.Base', \t\tsj.isType(a, sj.Base)],\r\n\t\t['aa isType sj.Base', \t\tsj.isType(aa, sj.Base)],\r\n\t\t['aaa isType sj.Base', \t\tsj.isType(aaa, sj.Base)],\r\n\r\n\t\t// SIBLINGS\r\n\t\t['a !isType B', !sj.isType(a, B)],\r\n\t\t['aa !isType AB', !sj.isType(aa, AB)],\r\n\t\t['aaa !isType AAB', !sj.isType(aaa, AAB)],\r\n\r\n\t\t// COUSINS\r\n\t\t['aa !isType BA', !sj.isType(aa, BA)],\r\n\r\n\t\t// INSTANCES\r\n\t\t['a.constructor === A',\t\ta.constructor === A],\r\n\t\t['aa.constructor === AA',\taa.constructor === AA],\r\n\t\t['aaa.constructor === AAA',\taaa.constructor === AAA],\r\n\r\n\r\n\t\t// MAKE CLASS FUNCTIONS\r\n\t\t['called constructorParts',\t\tcalledConstructorParts],\r\n\t\t['called beforeInitialize',\t\tcalledBeforeInitialize],\r\n\t\t['called afterInitialize',\t\tcalledAfterInitialize],\r\n\t\t['called prototypeProperties',\tcalledPrototypeProperties],\r\n\t\t['called staticProperties',\t\tcalledStaticProperties],\r\n\t\t['did not call extraFunction',\t!calledExtraFunction],\r\n\r\n\t\t// PROPERTIES EXIST\r\n\t\t['a before property',\t\ta.hasOwnProperty('beforeFoo')],\r\n\t\t['a default property',\t\ta.hasOwnProperty('defaultFoo')],\r\n\t\t['a after property',\t\ta.hasOwnProperty('afterFoo')],\r\n\t\t['A.prototype property',\tObject.getPrototypeOf(a).hasOwnProperty('prototypeFoo')],\r\n\t\t['A static property',\t\tA.hasOwnProperty('staticFoo')],\r\n\r\n\t\t// PROPERTY INHERITANCE\r\n\t\t//! before and after will generate new instances, even if function is inherited\r\n\t\t['aa.beforeFoo === a.beforeFoo',\t\t\taa.beforeFoo !== undefined && aa.beforeFoo !== a.beforeFoo], \r\n\t\t['aa.defaultFoo === a.defaultFoo',\t\t\taa.defaultFoo === a.defaultFoo],\r\n\t\t['aa.afterFoo === a.afterFoo',\t\t\t\taa.defaultFoo !== undefined && aa.afterFoo !== a.afterFoo],\r\n\t\t['AA.prototype foo === A.prototype foo',\tAA.prototype.prototypeFoo === A.prototype.prototypeFoo],\r\n\t\t['AA static foo === A static foo',\t\t\tAA.staticFoo === A.staticFoo],\r\n\r\n\t\t// PROPERTY EXTENSION\r\n\t\t['aa.beforeFoo2 exists',\t\taa.afterFoo2 !== undefined && aa.afterFoo2 !== aa.afterFoo],\r\n\t\t['aa.defaultFoo2 exists',\t\taa.defaultFoo2 !== undefined && aa.defaultFoo2 !== aa.defaultFoo],\r\n\t\t['aa.afterFoo2 exists',\t\t\taa.afterFoo2 !== undefined && aa.beforeFoo2 !== aa.beforeFoo],\r\n\t\t['AA.prototype foo2 exists',\tAA.prototype.prototypeFoo2 !== undefined && AA.prototype.prototypeFoo2 !== AA.prototype.prototypeFoo],\r\n\t\t['AA static foo2 exists',\t\tAA.staticFoo2 !== undefined && AA.staticFoo2 !== AA.staticFoo],\r\n\r\n\t\t// PROPERTY OVERWRITE\r\n\t\t['ab.beforeFoo exists and !== a.beforeFoo',\t\tab.beforeFoo !== undefined && ab.beforeFoo !== a.beforeFoo],\r\n\t\t['ab.defaultFoo exists and !== a.defaultFoo',\tab.defaultFoo !== undefined && ab.defaultFoo !== a.defaultFoo],\r\n\t\t['ab.afterFoo exists and !== a.afterFoo',\t\tab.afterFoo !== undefined && ab.afterFoo !== a.afterFoo],\r\n\t\t['AB.prototype foo exists !== B.prototype foo',\tAB.prototype.prototypeFoo !== undefined && AB.prototype.prototypeFoo !== A.prototype.prototypeFoo],\r\n\t\t['AB static foo exists !== A static foo',\t\tAB.staticFoo !== undefined && AB.staticFoo !== A.staticFoo],\r\n\r\n\t\t// AUGMENT CLASS\r\n\t\t['c2.beforeBar exists and !== c.beforeBar',\t\t\t\t\tc2.beforeBar !== undefined && c2.beforeBar !== c.beforeBar],\r\n\t\t['c2.defaultBar exists and !== c.defaultBar',\t\t\t\tc2.defaultBar !== undefined && c2.defaultBar !== c.defaultBar],\r\n\t\t['c2.afterBar exists and !== c.afterBar',\t\t\t\t\tc2.afterBar !== undefined && c2.afterBar !== c.afterBar],\r\n\t\t['c.constructor.prototype === c2.constructor.prototype',\tObject.getPrototypeOf(c) === Object.getPrototypeOf(c2)],\r\n\t\t['c.constructor === c2.constructor',\t\t\t\t\t\tc.constructor === c2.constructor],\r\n\r\n\r\n\t\t// PASSED OPTIONS\r\n\t\t['a.passedFoo !== a2.passedFoo', a.passedFoo !== a2.passedFoo],\r\n\t\t['undefined default',\t\t\t!a.hasOwnProperty('undefinedFoo')],\r\n\t\t['undeclared default',\t\t\t!a.hasOwnProperty('undeclaredFoo')],\r\n\t\t['undefined option',\t\t\t!a.hasOwnProperty('undefinedFoo')],\r\n\t], 'sj.Base Classes');\r\n};\r\n\r\n\r\n// ERROR\r\nsj.Error = sj.Base.makeClass('Error', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\tlog: true, //TODO remove log: true from errors\r\n\t\t\tcode: 400,\r\n\t\t\ttype: 'Bad Request',\r\n\t\t},\r\n\t}),\r\n});\r\nsj.ErrorList = sj.Base.makeClass('ErrorList', sj.Error, {\r\n\tconstructorParts: parent => ({\r\n\t\t//C wrapper for an array with one or more errors\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\treason: 'one or more errors occurred with items',\r\n\t\t\tcontent: [],\r\n\t\t},\r\n\t}),\r\n});\r\n// CUSTOM ERROR\r\nsj.SilentError = sj.Base.makeClass('SilentError', sj.Error, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\tlog: false,\r\n\t\t},\r\n\t}),\r\n});\r\nsj.AuthRequired = sj.Base.makeClass('AuthRequired', sj.Error, {\r\n\t//C used to communicate to client that the server does not have the required tokens and that the client must authorize\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\tmessage: 'authorization required',\r\n\t\t},\r\n\t}),\r\n});\r\nsj.Unreachable = sj.Base.makeClass('Unreachable', sj.Error, {\r\n\t//C used to indicate an unreachable place in the code\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\tmessage: 'code reached a place that should be unreachable',\r\n\t\t},\t\r\n\t}),\r\n});\r\nsj.Timeout = sj.Base.makeClass('Timeout', sj.Error, {\r\n\t//C used to indicate a timed-out function\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\tmessage: 'request timed out',\r\n\t\t},\r\n\t}),\r\n});\r\n\r\n\r\n// RULE\r\nsj.Rule = sj.Base.makeClass('Rule', sj.Base, {\r\n\t//G//! arrow functions may be used to shorten object returns, however they should must not use 'this'\r\n\tconstructorParts: parent => ({\r\n\t\t//G//! 'this' refers to the static class inside constructorParts(), however 'this' refers to the instance inside before/afterInitialize()\r\n\t\tdefaults: {\r\n\t\t\t// NEW\r\n\t\t\tvalueName: 'input',\r\n\t\t\ttrim: false,\r\n\t\t\t\r\n\t\t\tdataTypes: ['string'],\r\n\t\r\n\t\t\tmin: 0,\r\n\t\t\tmax: Infinity,\r\n\t\r\n\t\t\t\r\n\t\t\t//! remember to set useAgainst: true, if passing a value2 to use\r\n\t\t\tuseAgainst: false,\r\n\t\t\t//C this is a reference value and should not be able to be equal to anything,\r\n\t\t\t//R this is to prevent a user from somehow passing in boolean false, thus making it equal to the against value and passing a password check\r\n\t\t\tagainstValue: {},\r\n\t\t\tget againstMessage() {\r\n\t\t\t\t//! this reveals password2 when checking two passwords - simply overwrite this get function to a custom message\r\n\t\r\n\t\t\t\tlet againstValueName = this.againstValue;\r\n\t\t\t\t//C join array of values if matching against multiple values\r\n\t\t\t\tif (Array.isArray(this.againstValue)) {\r\n\t\t\t\t\tagainstValueName = this.againstValue.join(', ');\r\n\t\t\t\t}\r\n\t\t\t\treturn `${this.valueName} did not match against these values: ${againstValueName}`;\r\n\t\t\t},\r\n\t\r\n\t\t\t//! remember to set useFilter: true, if passing a value2 to use\r\n\t\t\tuseFilter: false,\r\n\t\t\t//C match nothing //TODO verify this\r\n\t\t\t//L https://stackoverflow.com/questions/2930182/regex-to-not-match-any-characters\r\n\t\t\tfilterExpression: '\\\\b\\\\B',\r\n\t\t\tfilterRequirements: 'none',\r\n\t\t\tget filterMessage() {\r\n\t\t\t\treturn `${this.valueName} did not meet these requirements: ${this.filterRequirements}`;\r\n\t\t\t},\r\n\t\r\n\t\t\tcustom: undefined,\r\n\t\t},\r\n\t}),\r\n\tprototypeProperties: parent => ({\r\n\t\t//TODO how to deal with returning the password field since its sensitive\r\n\t\tasync checkType(value) {\r\n\t\t\t//C check against each datatype\r\n\t\t\tfor (let i = 0; i < this.dataTypes.length; i++) {\r\n\t\t\t\tif (sj.isType(value, this.dataTypes[i])) {\r\n\t\t\t\t\treturn new sj.Success({\r\n\t\t\t\t\t\torigin: `${this.origin}.checkType()`,\r\n\t\t\t\t\t\tmessage: 'validated data type',\r\n\t\t\t\t\t\tcontent: value,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//C parse strings for numbers\r\n\t\t\t\tif (sj.isType(value, String)) {\r\n\t\t\t\t\tlet parsed = Number.parseFloat(value);\r\n\t\t\t\t\tif (this.dataTypes[i] === 'number' && !Number.isNaN(parsed) \r\n\t\t\t\t\t|| this.dataTypes[i] === 'integer' && Number.isInteger(parsed)) {\r\n\t\t\t\t\t\treturn new sj.Success({\r\n\t\t\t\t\t\t\torigin: `${this.origin}.checkType()`,\r\n\t\t\t\t\t\t\tmessage: 'validated data type',\r\n\t\t\t\t\t\t\tcontent: parsed,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//TODO parse strings for boolean & symbols & other?\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//C throw if no matches\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: `${this.origin}.checkType()`,\r\n\t\t\t\tmessage: `${this.valueName} must be a ${this.dataTypes.join(' or ')}`,\r\n\t\t\t\tcontent: value,\r\n\t\t\t});\r\n\t\t},\r\n\t\tasync checkSize(value) {\r\n\t\t\tlet m = `${this.valueName} must be between ${this.min} and ${this.max}`;\r\n\r\n\t\t\tif (sj.isType(value, String)) {\r\n\t\t\t\t//C string length\r\n\t\t\t\tif (!(value.length >= this.min && value.length <= this.max)) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: `${this.origin}.checkSize()`,\r\n\t\t\t\t\t\tmessage: `${m} characters long`,\r\n\t\t\t\t\t\tcontent: value,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else if (sj.isType(value, Number)) {\r\n\t\t\t\t//C number size\r\n\t\t\t\tif (!(value >= this.min && value <= this.max)) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: `${this.origin}.checkSize()`,\r\n\t\t\t\t\t\tmessage: `${m} items long`,\r\n\t\t\t\t\t\tcontent: value,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn new sj.Success({\r\n\t\t\t\torigin: `${this.origin}.checkSize()`,\r\n\t\t\t\tcontent: value,\r\n\t\t\t});\r\n\t\t},\r\n\t\tasync checkAgainst (value, value2) {\r\n\t\t\t//C custom againstValue\r\n\t\t\tif (!sj.isType(value2, undefined)) {\r\n\t\t\t\tthis.againstValue = value2;\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(this.againstValue)) {\r\n\t\t\t\t//C arrays\r\n\t\t\t\t//R indexOf apparently uses === so this should be fine\r\n\t\t\t\t//L https://stackoverflow.com/questions/44172530/array-indexof-insensitive-data-type\r\n\t\t\t\tif (this.againstValue.indexOf(value) === -1) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: `${this.origin}.checkAgainst() array`,\r\n\t\t\t\t\t\tmessage: this.againstMessage,\r\n\t\t\t\t\t\tcontent: value,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t//C base value\r\n\t\t\t\tif (!(value === this.againstValue)) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: `${this.origin}.checkAgainst() non-array`,\r\n\t\t\t\t\t\tmessage: this.againstMessage,\r\n\t\t\t\t\t\tcontent: value,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn new sj.Success({\r\n\t\t\t\torigin: `${this.origin}.checkAgainst()`,\r\n\t\t\t\tcontent: value,\r\n\t\t\t});\r\n\t\t},\r\n\t\tasync checkFilter(value, value2) {\r\n\t\t\t//C custom againstValue\r\n\t\t\tif (sj.isType(value2, undefined)) {\r\n\t\t\t\tthis.filterExpression = value2;\r\n\t\t\t}\r\n\r\n\t\t\t//TODO\r\n\r\n\t\t\treturn new sj.Success({\r\n\t\t\t\torigin: `${this.origin}.checkAgainst()`,\r\n\t\t\t\tcontent: value,\r\n\t\t\t});\r\n\t\t},\r\n\r\n\t\tasync checkCustom(value) {\r\n\t\t\tif (typeof this.custom === 'function') {\r\n\t\t\t\treturn this.custom(value);\r\n\t\t\t} else {\r\n\t\t\t\treturn new sj.Success({\r\n\t\t\t\t\torigin: `${this.origin}.checkCustom()`,\r\n\t\t\t\t\tcontent: value,\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/* //OLD\r\n\t\t\t//TODO //! convert this.dataType to this.dataTypes forEach loop if re implementing this as in checkType()\r\n\t\t\tcheckType(value) {\r\n\t\t\t\tlet t = sj.typeOf(value);\r\n\r\n\t\t\t\t//C if value is a string and dataType is a number or integer\r\n\r\n\t\t\t\tif (this.dataType === 'number' && t === 'string') {\r\n\t\t\t\t\t//C\ttry to parse the string and check if it is a number\r\n\t\t\t\t\t//L\thttps://www.w3schools.com/jsref/jsref_parsefloat.asp\r\n\t\t\t\t\tlet p = parseFloat(value);\r\n\t\t\t\t\tif (!Number.isNaN(p)) {\r\n\t\t\t\t\t\t//C if so, convert it to the parsed number and return\r\n\t\t\t\t\t\tvalue = p;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.dataType === 'integer') {\r\n\t\t\t\t\tif (t === 'string') {\r\n\t\t\t\t\t\tlet p = parseInt(value);\r\n\t\t\t\t\t\tif (Number.isInteger(p)) {\r\n\t\t\t\t\t\t\tvalue = p;\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if not a string, just see if its an integer\r\n\t\t\t\t\treturn Number.isInteger(value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn t === this.dataType;\r\n\t\t\t}\r\n\t\t\tcheckSize(value) {\r\n\t\t\t\tif (sj.typeOf(value) === 'string' || sj.typeOf(value) === 'array') {\r\n\t\t\t\t\treturn value.length >= this.min && value.length <= this.max;\r\n\t\t\t\t} else if (sj.typeOf(value) === 'number') {\r\n\t\t\t\t\treturn value >= this.min && value <= this.max;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t\tcheckAgainst(value, value2) {\r\n\t\t\t\t// allow custom check against value\r\n\t\t\t\tif (sj.typeOf(value2) !== 'undefined') {\r\n\t\t\t\t\tthis.againstValue = value2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (Array.isArray(this.againstValue)) {\r\n\t\t\t\t\treturn this.againstValue.indexOf(value) !== -1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//! no type coercion\r\n\t\t\t\t\treturn value === this.againstValue;\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t\tcheckFilter(value, value2) {\r\n\t\t\t\t//TODO regex, similar to checkAgainst\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t*/\r\n\r\n\t\t//! validation and type conversion (and //TODO security, and database checks) are all part of this Rules check\r\n\t\t//TODO should sj.Rule be exposed in globals if it contains the security checks? is that safe? - ideally, database checks should also be implemented so 'name already taken' errors show up at the same time basic validation errors do. Basically theres three waves in most cases - isLoggedIn (ok to be in a separate wave because it should rarely happen, and assumes the user knows what they're doing except being logged in - or would this be useful in the same wave too?), basic validation, database validation. < SHOULD ALL VALIDATION CHECKS BE IN ONE WAVE?\r\n\r\n\t\t//! to use the possibly modified value from check(), set the input value to equal the result.content\r\n\t\tasync check(value, value2) {\r\n\t\t\t//L Guard Clauses: https://medium.com/@scadge/if-statements-design-guard-clauses-might-be-all-you-need-67219a1a981a\r\n\t\t\t//C Guard clauses (for me) should be positively-phrased conditions - but wrapped in a single negation: if(!(desiredCondition)) {}\r\n\r\n\t\t\t//C trim\r\n\t\t\tif (this.trim && sj.isType(value, String)) {\r\n\t\t\t\tvalue = value.trim();\r\n\t\t\t}\r\n\r\n\t\t\t//C checks & possibly modifies\r\n\t\t\tvalue = await this.checkType(value).then(sj.content); //R no need to catch and return the content as it will be in the thrown error anyways\r\n\t\t\tawait this.checkSize(value);\r\n\t\t\tif (this.useAgainst) {\r\n\t\t\t\tawait this.checkAgainst(value, value2);\r\n\t\t\t}\r\n\t\t\tif (this.useFilter) {\r\n\t\t\t\tawait this.checkFilter(value, value2);\r\n\t\t\t}\r\n\t\t\tif (typeof this.custom === 'function') {\r\n\t\t\t\tawait this.checkCustom(value);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\t\tif (!this.checkType(value)) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: this.log,\r\n\t\t\t\t\t\torigin: this.origin,\r\n\t\t\t\t\t\tmessage: `${this.valueName} must be a ${this.dataType}`,\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (this.trim && sj.typeOf(value) === 'string') {\r\n\t\t\t\t\tvalue = value.trim();\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (!this.checkSize(value)) {\r\n\t\t\t\t\tlet message = `${this.valueName} must be between ${this.min} and ${this.max}`;\r\n\t\t\t\t\tif (sj.typeOf(value) === 'string') {\r\n\t\t\t\t\t\tmessage = `${message} characters long`;\r\n\t\t\t\t\t} else if (sj.typeOf(value) === 'array') {\r\n\t\t\t\t\t\tmessage = `${message} items long`;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: this.log,\r\n\t\t\t\t\t\torigin: this.origin,\r\n\t\t\t\t\t\tmessage: message,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tif (this.useAgainst && !this.checkAgainst(value, value2)) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: this.log,\r\n\t\t\t\t\t\torigin: this.origin,\r\n\t\t\t\t\t\tmessage: this.againstMessage,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tif (this.useFilter && !this.checkFilter(value, value2)) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: this.log,\r\n\t\t\t\t\t\torigin: this.origin,\r\n\t\t\t\t\t\tmessage: this.filterMessage,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t*/\r\n\t\t\t\r\n\t\t\t//C remove error-related properties\r\n\t\t\tthis.target = undefined;\r\n\t\t\t//TODO consider inputCorrect styling\r\n\t\t\tthis.cssClass = undefined; \r\n\t\t\tthis.content = value;\r\n\t\t\t//C transform object (this will strip any irrelevant properties away)\r\n\t\t\treturn new sj.Success(this); \t\t\r\n\t\t},\r\n\r\n\t\t/* //OLD decided this was redundant\r\n\t\t\t//C checks an object's property and possibly modify it, this is done so that properties can be passed and modified by reference for lists\r\n\t\t\t//? this may not be needed over check(), see sj.Rule.checkRuleSet() in global-server.mjs\r\n\t\t\tasync checkProperty(obj, prop, value2) {\r\n\t\t\t\t//C validate arguments\r\n\t\t\t\tif (!sj.isType(obj, 'object')) {\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: 'sj.Rule.checkProperty()',\r\n\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\treason: `sj.Rule.checkProperty()'s first argument is not an object`,\r\n\t\t\t\t\t\tcontent: obj,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tif (!prop in obj) {\r\n\t\t\t\t\t//L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: 'sj.Rule.checkProperty()',\r\n\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\treason: `sj.Rule.checkProperty()'s object argument is missing a '${prop}' property`,\r\n\t\t\t\t\t\tcontent: obj,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//C check rules\r\n\t\t\t\tlet result = this.check(obj[prop], value2).catch(rejected => {\r\n\t\t\t\t\t//C throw error if failed \r\n\t\t\t\t\t//! do not modify the original property, so that sj.Error.content is not relied upon to always be the original property\r\n\t\t\t\t\tthrow sj.propagate(rejected);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t//C modify and return if successful\r\n\t\t\t\tobj[prop] = result.content;\r\n\t\t\t\treturn result;\r\n\t\t\t}\r\n\t\t*/\r\n\t\t/* //OLD, new check ruleset was created in global-server.mjs\r\n\t\t\tstatic async checkRuleSet(ruleSet) {\r\n\t\t\t\t//C takes a 2D array of [[sj.Rule, obj, propertyName, value2(optional)], [], [], ...]\r\n\t\t\t\treturn Promise.all(ruleSet.map(async ([rules, obj, prop, value2]) => {\r\n\t\t\t\t\t//L destructuring: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\r\n\r\n\t\t\t\t\t//C validate arguments\r\n\t\t\t\t\tif (!rules instanceof this) {\r\n\t\t\t\t\t\treturn new sj.Error({\r\n\t\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\t\torigin: 'checkRuleSet()',\r\n\t\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\t\treason: `checkRuleSet() is missing a sj.Rule object`,\r\n\t\t\t\t\t\t\tcontent: rules,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//C check, return errors too\r\n\t\t\t\t\treturn await rules.checkProperty(obj, prop, value2).catch(sj.andResolve);\r\n\t\t\t\t})).then(resolved => {\r\n\t\t\t\t\t//C filter for sj.Success objects\r\n\t\t\t\t\treturn sj.filterList(resolved, sj.Success, new sj.Success({\r\n\t\t\t\t\t\torigin: 'sj.Rule.checkRuleSet()',\r\n\t\t\t\t\t\tmessage: 'all rules validated',\r\n\t\t\t\t\t}), new sj.Error({\r\n\t\t\t\t\t\torigin: 'sj.Rule.checkRuleSet()',\r\n\t\t\t\t\t\tmessage: 'one or more issues with rules',\r\n\t\t\t\t\t\treason: 'validation functions returned one or more errors',\r\n\t\t\t\t\t}));\r\n\t\t\t\t}).catch(rejected => {\r\n\t\t\t\t\tthrow sj.propagate(rejected);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t*/\r\n\t\t/* //OLD\r\n\t\t\t//! checkRuleSet takes a reference object and the property name, value modification is then done automatically\r\n\t\t\tstatic async checkRuleSet(ruleSet) {\r\n\t\t\t\t//C takes a 2D array of [[sj.Rule, obj, propertyName, value2(optional)], [], [], ...]\r\n\r\n\t\t\t\treturn Promise.all(ruleSet.map(async ([rules, obj, prop, value2]) => { \r\n\t\t\t\t\t//L destructuring: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\r\n\r\n\t\t\t\t\t//C validate arguments\r\n\t\t\t\t\tif (!(rules instanceof sj.Rule)) {\r\n\t\t\t\t\t\t//L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof\r\n\t\t\t\t\t\t//? is it possible to dynamically get this class\r\n\t\t\t\t\t\treturn new sj.Error({\r\n\t\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\t\torigin: 'checkRuleSet()',\r\n\t\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\t\treason: `checkRuleSet() is missing a sj.Rule object`,\r\n\t\t\t\t\t\t\tcontent: rules,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!(typeof obj === 'object' && sj.typeOf(obj) !== 'null')) {\r\n\t\t\t\t\t\t//R cannot use just sj.typeOf(obj) here because it won't properly recognize any 'object'\r\n\t\t\t\t\t\treturn new sj.Error({\r\n\t\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\t\torigin: 'checkRuleSet()',\r\n\t\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\t\treason: `checkRuleSet() is missing an object argument`,\r\n\t\t\t\t\t\t\tcontent: obj,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (!(prop in obj)) {\r\n\t\t\t\t\t\t//L https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in\r\n\t\t\t\t\t\treturn new sj.Error({\r\n\t\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\t\torigin: 'checkRuleSet()',\r\n\t\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\t\treason: `checkRuleSet() obj is missing a '${prop}' property`,\r\n\t\t\t\t\t\t\tcontent: obj,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet result = new sj.Error(); //? why is this here\r\n\r\n\t\t\t\t\t//C call check() with 1 or 2 values\r\n\t\t\t\t\tif (sj.typeOf(value2) === 'undefined') {\r\n\t\t\t\t\t\tresult = await rules.check(obj[prop]).then(sj.sj.andResolve());\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tresult = await rules.check(obj[prop], value2).then(sj.sj.andResolve());\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//C pass the possibly modified value back to the original object\r\n\t\t\t\t\tobj[prop] = result.content;\r\n\r\n\t\t\t\t\treturn result;\r\n\t\t\t\t})).then(resolved => {\r\n\t\t\t\t\treturn sj.filterList(resolved, sj.Success, new sj.Success({\r\n\t\t\t\t\t\torigin: 'checkRuleSet()',\r\n\t\t\t\t\t\tmessage: 'all rules validated',\r\n\t\t\t\t\t}), new sj.Error({\r\n\t\t\t\t\t\torigin: 'checkRuleSet()',\r\n\t\t\t\t\t\tmessage: 'one or more issues with fields',\r\n\t\t\t\t\t\treason: 'validation functions returned one or more errors',\r\n\t\t\t\t\t}));\r\n\t\t\t\t}).catch(rejected => {\r\n\t\t\t\t\tthrow sj.propagate(rejected);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t*/\r\n\t}),\r\n\tstaticProperties: parent => ({\r\n\t\t//! string to be hashed must not be greater than 72 characters (//? or bytes???),\r\n\t\tstringMaxLength: 100,\r\n\t\tbigStringMaxLength: 2000,\r\n\t\tnameMinLength: 3,\r\n\t\tnameMaxLength: 16,\r\n\t\tdefaultColor: '#ffffff',\r\n\t\tvisibilityStates: [\r\n\t\t\t'public',\r\n\t\t\t'private',\r\n\t\t\t'linkOnly',\r\n\t\t],\r\n\t}),\r\n});\r\nsj.Rule.augmentClass({ //C add custom sj.Rules as statics of sj.Rule\r\n\tstaticProperties: parent => ({\r\n\t\tnone: new sj.Rule({\r\n\t\t\torigin: 'noRules',\r\n\t\t\tmessage: 'value validated',\r\n\t\t\r\n\t\t\tvalueName: 'Value',\r\n\t\t\r\n\t\t\tdataTypes: ['string', 'number', 'boolean', 'array'], //TODO etc. or just make functionality for this\r\n\t\t}),\r\n\t\tposInt: new sj.Rule({\r\n\t\t\torigin: 'positiveIntegerRules',\r\n\t\t\tmessage: 'number validated',\r\n\t\t\r\n\t\t\tvalueName: 'Number',\r\n\t\t\r\n\t\t\tdataTypes: ['integer'],\r\n\t\t}),\r\n\t\tid: new sj.Rule({\r\n\t\t\torigin: 'idRules',\r\n\t\t\tmessage: 'id validated',\r\n\t\t\r\n\t\t\tvalueName: 'id',\r\n\t\t\r\n\t\t\tdataTypes: ['integer'],\r\n\t\t}),\r\n\t\timage: new sj.Rule({\r\n\t\t\torigin: 'imageRules',\r\n\t\t\tmessage: 'image validated',\r\n\t\t\ttarget: 'playlistImage',\r\n\t\t\tcssClass: 'inputError',\r\n\t\t\r\n\t\t\tvalueName: 'image',\r\n\t\t\ttrim: true,\r\n\t\t\r\n\t\t\tmax: sj.Rule.bigStringMaxLength,\r\n\t\t\r\n\t\t\t// TODO filter: ___,\r\n\t\t\tfilterMessage: 'Image must be a valid url',\r\n\t\t}),\r\n\t\tcolor: new sj.Rule({\r\n\t\t\torigin: 'colorRules',\r\n\t\t\tmessage: 'color validated',\r\n\t\t\ttarget: 'playlistColor',\r\n\t\t\tcssClass: 'inputError',\r\n\t\t\r\n\t\t\tvalueName: 'color',\r\n\t\t\ttrim: true,\r\n\t\t\t\r\n\t\t\tfilter: '/#([a-f0-9]{3}){1,2}\\b/', //TODO is this correct?\r\n\t\t\tfilterMessage: 'Color must be in hex format #XXXXXX',\r\n\t\t}),\r\n\t\tvisibility: new sj.Rule({\r\n\t\t\torigin: 'visibilityRules',\r\n\t\t\tmessage: 'visibility validated',\r\n\t\t\ttarget: 'playlistVisibility',\r\n\t\t\tcssClass: 'inputError',\r\n\t\t\r\n\t\t\tvalueName: 'Visibility',\r\n\t\t\r\n\t\t\tuseAgainst: true,\r\n\t\t\tagainstValue: sj.Rule.visibilityStates,\r\n\t\t\tagainstMessage: 'please select a valid visibility level',\r\n\t\t}),\r\n\r\n\t\t//TODO other / old\r\n\t\t//? not sure what these were used for\r\n\t\tself: new sj.Rule({\r\n\t\t\torigin: 'selfRules',\r\n\t\t\tmessage: 'self validated',\r\n\t\t\ttarget: 'notify',\r\n\t\t\tcssClass: 'notifyError',\r\n\t\t\r\n\t\t\tvalueName: 'Id',\r\n\t\t\r\n\t\t\tdataTypes: ['integer'],\r\n\t\t\r\n\t\t\tuseAgainst: true,\r\n\t\t\t//! ctx.session.user.id shouldn't be used here because there is no guarantee ctx.session.user exists\r\n\t\t\tagainstMessage: 'you are not the owner of this',\r\n\t\t}),\r\n\t\tsetPassword: new sj.Rule({\r\n\t\t\torigin: 'setPasswordRules',\r\n\t\t\tmessage: 'password validated',\r\n\t\t\ttarget: 'registerPassword',\r\n\t\t\tcssClass: 'inputError',\r\n\t\t\r\n\t\t\tvalueName: 'Password',\r\n\t\t\r\n\t\t\tmin: 6,\r\n\t\t\tmax: 72, //! as per bcrypt\r\n\t\t\r\n\t\t\tuseAgainst: true,\r\n\t\t\tget againstMessage() {return 'Passwords do not match'},\r\n\t\t}),\r\n\t}),\r\n});\r\n\r\nsj.Rule2 = sj.Base.makeClass('Rule2', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tbeforeInitialize(accessory) {\r\n\t\t\tif (\r\n\t\t\t\ttypeof accessory.options.baseValidate !== 'function' ||\r\n\t\t\t\ttypeof accessory.options.baseCast !== 'function'\r\n\t\t\t) throw new sj.Error({\r\n\t\t\t\torigin: 'sj.Rule2.beforeInit()',\r\n\t\t\t\treason: 'baseValidate or baseCast is not a function',\r\n\t\t\t\tcontent: sj.image(accessory.options),\r\n\t\t\t});\r\n\t\t},\r\n\t\tdefaults: {\r\n\t\t\t//G baseValidate() and baseCast() may be synchronous or async, the caller should know which. But if it doesn't, call with await, as it wont affect the result of synchronous functions.\r\n\r\n\t\t\t//G baseValidate() should have one or many, sequential and/or parallel conditions that do nothing if passed and throw a specific error (with placeholders) if failed, this error should be SilentError/log: false, as it is caught and processed in validate()\r\n\t\t\tbaseValidate(value, accessory) {\r\n\t\t\t\tthrow new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.baseValidate()',\r\n\t\t\t\t\treason: `a baseValidate() function has not been created for this rule: ${this.name}`,\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\t//G baseCast() should have one or more sequential casting functions (which may error freely) that modify accessory.castValue\r\n\t\t\t//G baseCast() may use other rule's casting methods. but because they have their own internal casting steps, pass the castValue and the accessory object so that even if the casting function fails, the castValue will still retain any modifications: rule.validateCast(accessory.castValue, accessory); \r\n\t\t\t//R this is important because otherwise the casting method will just fail, leaving the castValue as the original, causing unexpected error messages (casting '4' as an integer would fail with 'not a number' instead of 'not an integer' because first the number casting would fail, leaving the castValue as a string, then validation would return the 'not a number' error).\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tnew sj.Warn({\r\n\t\t\t\t\tlog: true,\r\n\t\t\t\t\torigin: 'sj.Rule2.baseCast()',\r\n\t\t\t\t\treason: `a baseCast() function has not been created for this rule: ${this.name}`,\r\n\t\t\t\t});\r\n\t\t\t},\r\n\r\n\t\t\t//C string or array of strings used to replace $0, $1, $2... of specific properties (reason and message so far) of an error and it's content errors if error is an ErrorList\r\n\t\t\tfill: 'Value',\r\n\t\t},\r\n\t\tafterInitialize() {\r\n\t\t\t//C baseValidate and baseCast are guaranteed to be functions, this distinguishes between 'Function' and 'AsyncFunction'\r\n\t\t\tconst isValidateSync = this.baseValidate.constructor.name === 'Function';\r\n\t\t\tconst isCastSync = this.baseCast.constructor.name === 'Function';\r\n\r\n\t\t\t//C try-catch blocks are used for both async and sync to increase clarity\r\n\r\n\t\t\tif (isValidateSync) {\r\n\t\t\t\t//C calls baseValidate(), returns value on pass, throws a processed error on fail\r\n\t\t\t\tthis.validate = function (value, accessory = {}) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tthis.baseValidate(value, accessory);\r\n\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tthrow this.processError(e, accessory);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\t//C calls validate but instead returns true on pass and false on error\r\n\t\t\t\tthis.check = function (value, accessory = {}) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tthis.validate(value, accessory);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tthis.validate = async function (value, accessory = {}) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait this.baseValidate(value, accessory);\r\n\t\t\t\t\t\treturn value;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tthrow this.processError(e, accessory);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tthis.check = async function (value, accessory = {}) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait this.validate(value, accessory);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (isValidateSync && isCastSync) {\r\n\t\t\t\t//C validate that uses the value from cast() instead of the original value, also returns the cast value\r\n\t\t\t\tthis.validateCast = function (value, accessory = {}) {\r\n\t\t\t\t\t//C Casted values are stored on the accessory object so that upon error, the last successfully cast value can be used. \r\n\t\t\t\t\t//R This removes the need to write a bunch of try/catch blocks inside the baseCast method.\r\n\t\t\t\t\t//R cast() was originally it's own function, however it was moved into validateCast() because it wasn't supposed to be used on its own as the casted value wasn't guaranteed to be correctly cast without throwing an error, as some values cannot be cast (negative to positive) it would've involved just re-validating the cast inside the function which is redundant.\r\n\r\n\t\t\t\t\t//C The castValue starts as the original value.\r\n\t\t\t\t\taccessory.castValue = value;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\t//C Don't throw upon baseCast() error, just use the last successful castValue and apply the respective validate() error.\r\n\t\t\t\t\t\t/* //R \r\n\t\t\t\t\t\t\twhy not just throw the error and forget about the last successfully cast value?\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tcasting errors aren't very user friendly (because the user won't know what cast means), so just delegate the error handling to whats already written in the validate function\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tExample: while '2.35' can be cast to the number, it cannot (in this example) be cast to an integer. the validator will throw 'number is not an integer' for this STRING, rather than having cast throw 'cannot cast number to integer'.\r\n\t\t\t\t\t\t*/\r\n\t\t\t\t\t\tthis.baseCast(accessory);\r\n\t\t\t\t\t} catch (e) {};\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\treturn this.validate(accessory.castValue, accessory);\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tthrow this.processError(e, accessory);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\t//C same as check(), just uses validateCast() instead of validate()\r\n\t\t\t\tthis.checkCast = function (value, accessory = {}) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tthis.validateCast(value, accessory);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t} else {\r\n\t\t\t\tthis.validateCast = async function (value, accessory = {}) {\r\n\t\t\t\t\taccessory.castValue = value;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait this.baseCast(accessory);\r\n\t\t\t\t\t} catch (e) {};\r\n\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\treturn await this.validate(accessory.castValue, accessory);\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\tthrow this.processError(e, accessory);\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tthis.checkCast = async function (value, accessory = {}) {\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tawait this.validateCast(value, accessory);\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t} catch (e) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t},\r\n\t}),\r\n\tprototypeProperties(parent) {\r\n\t\t//C name property is tied to the rule-instance's key inside sj.Rule2, otherwise undefined\r\n\t\tObject.defineProperty(this, 'name', {\r\n\t\t\tget() {\r\n\t\t\t\treturn Object.keys(this.constructor).find(key => this.constructor[key] === this);\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\treturn {\r\n\t\t\tfillError(error, fill) {\r\n\t\t\t\t//C replace placeholders\r\n\t\t\t\tsj.any(fill).forEach((item, index) => {\r\n\t\t\t\t\tconst string = String(item);\r\n\t\t\t\t\terror.reason = error.reason.replace(`$${index}`, string);\r\n\t\t\t\t\terror.message = error.message.replace(`$${index}`, string);\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tprocessError(targetError, {fill = this.fill, error, origin}) {\r\n\t\t\t\t//C may receive custom fill, error, and origin fields from accessory at call invocation\r\n\r\n\t\t\t\t//C fill error\r\n\t\t\t\tthis.fillError(targetError, fill);\r\n\t\r\n\t\t\t\t//C if ErrorList\r\n\t\t\t\tif (sj.isType(targetError, sj.ErrorList)) {\r\n\t\t\t\t\t//C fill each item\r\n\t\t\t\t\tfor (const listError of targetError.content) {\r\n\t\t\t\t\t\tthis.fillError(listError, fill);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t...targetError,\r\n\t\t\t\t\t//C custom properties //! will overwrite any filled properties\r\n\t\t\t\t\t...error,\r\n\t\t\t\t\t//C fixed properties\r\n\t\t\t\t\torigin,\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t};\r\n\t},\r\n});\r\nsj.Rule2.augmentClass({\r\n\tstaticProperties: parent => ({\r\n\t\t// STRING\r\n\t\tstring: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tif (!sj.isType(value, String)) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.string.baseValidate()',\r\n\t\t\t\t\treason: '$0 is not a string',\r\n\t\t\t\t\tmessage: '$0 must be text.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\t//C a failed stringify can still be turned in to a string\r\n\t\t\t\tif (typeof accessory.castValue === 'object') {\r\n\t\t\t\t\ttry { \r\n\t\t\t\t\t\taccessory.castValue = JSON.stringify(accessory.castValue); \r\n\t\t\t\t\t} catch (e) {} \r\n\t\t\t\t}\r\n\t\t\t\taccessory.castValue = String(accessory.castValue);\r\n\t\t\t},\r\n\t\t}),\r\n\t\ttrimmed: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.string.validate(value);\r\n\t\t\t\t//TODO ensure that this regExp checks for all possible white space\r\n\t\t\t\t//L from the trim() polyfill at: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\r\n\t\t\t\tif (/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g.test(value)) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.trimmed.baseValidate()',\r\n\t\t\t\t\treason: '$0 is not trimmed',\r\n\t\t\t\t\tmessage: '$0 must not have any leading or trailing whitespace.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.string.validateCast(accessory.castValue, accessory);\r\n\t\t\t\taccessory.castValue = accessory.castValue.trim();\r\n\t\t\t},\r\n\t\t}),\r\n\t\tnonEmptyString: new sj.Rule2({\r\n\t\t\t//C string has any non-whitespace characters\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.string.validate(value);\r\n\t\t\t\tif (value.trim() === '') throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.nonEmptyString.baseValidate()',\r\n\t\t\t\t\treason: '$0 is empty or only has whitespace',\r\n\t\t\t\t\tmessage: '$0 must not be empty.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.string.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//! cannot cast any further than a string\r\n\t\t\t},\r\n\t\t}),\r\n\r\n\t\t// NUMBER\r\n\t\tnumber: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tif (!sj.isType(value, Number)) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.number.baseValidate()',\r\n\t\t\t\t\treason: '$0 is not a number',\r\n\t\t\t\t\tmessage: '$0 must be a number.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\t//C parse strings for floats\r\n\t\t\t\t//! do not cast to NaN\r\n\t\t\t\tconst n = Number.parseFloat(accessory.castValue);\r\n\t\t\t\tif (!Number.isNaN(n)) accessory.castValue = n;\r\n\t\t\t},\r\n\t\t}),\r\n\t\tnonNaNNumber: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tif (!sj.isType(value, Number) || Number.isNaN(value)) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.nonNaNNumber.baseValidate()',\r\n\t\t\t\t\treason: '$0 is not a number or is NaN',\r\n\t\t\t\t\tmessage: '$0 must be a number.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.number.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//! don't cast NaN to a non-NaN number\r\n\t\t\t},\r\n\t\t}),\r\n\r\n\t\tnonNegativeNumber: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\t//L don't worry about NaN here: https://stackoverflow.com/a/26982925\r\n\t\t\t\tsj.Rule2.number.validate(value);\r\n\t\t\t\tif (value < 0) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.nonNegativeNumber.baseValidate()',\r\n\t\t\t\t\treason: '$0 is negative',\r\n\t\t\t\t\tmessage: '$0 must not be negative.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.number.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//! don't cast negative number to a non-negative number\r\n\t\t\t},\r\n\t\t}),\r\n\t\tnonPositiveNumber: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.number.validate(value);\r\n\t\t\t\tif (0 < value) {\r\n\t\t\t\t\tthrow new sj.SilentError({\r\n\t\t\t\t\t\torigin: 'sj.Rule2.nonPositiveNumber.baseValidate()',\r\n\t\t\t\t\t\treason: '$0 is positive',\r\n\t\t\t\t\t\tmessage: '$0 must not be positive.',\r\n\t\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.number.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//! don't cast positive number to a non-positive number\r\n\t\t\t},\r\n\t\t}),\r\n\t\tpositiveNumber: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\t//L don't worry about NaN here: https://stackoverflow.com/a/26982925\r\n\t\t\t\tsj.Rule2.number.validate(value);\r\n\t\t\t\tif (value <= 0) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.positiveNumber.baseValidate()',\r\n\t\t\t\t\treason: '$0 is negative or 0',\r\n\t\t\t\t\tmessage: '$0 must be positive.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.number.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//! don't cast non-positive number to a positive number\r\n\t\t\t},\r\n\t\t}),\r\n\t\tnegativeNumber: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.number.validate(value);\r\n\t\t\t\tif (0 <= value) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.negativeNumber.baseValidate()',\r\n\t\t\t\t\treason: '$0 is positive or 0',\r\n\t\t\t\t\tmessage: '$0 must be negative.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.number.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//! don't cast non-negative number to a negative number\r\n\t\t\t},\r\n\t\t}),\r\n\r\n\t\t// INTEGER\r\n\t\tinteger: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\t//L don't worry about NaN here: https://stackoverflow.com/a/26982925\r\n\t\t\t\tsj.Rule2.number.validate(value);\r\n\t\t\t\tif (!Number.isInteger(value)) throw new sj.SilentError({\r\n\t\t\t\t\torigin: 'sj.Rule2.integer.baseValidate()',\r\n\t\t\t\t\treason: '$0 is not an integer',\r\n\t\t\t\t\tmessage: '$0 must be an integer.',\r\n\t\t\t\t\tcontent: sj.image(value),\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.number.validateCast(accessory.castValue, accessory);\r\n\t\t\t\t//C chops any decimal off of floats\r\n\t\t\t\t//! this may give misleading errors, as the value will no longer fail because it's not an integer but because it's chopped value fails some other condition\r\n\t\t\t\taccessory.castValue = Number.parseInt(accessory.castValue);\r\n\t\t\t},\r\n\t\t}),\r\n\t\t\r\n\t\tnonNegativeInteger: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.nonNegativeNumber.validate(value);\r\n\t\t\t\tsj.Rule2.integer.validate(value);\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.nonNegativeNumber.validateCast(accessory.castValue, accessory);\r\n\t\t\t\tsj.Rule2.integer.validateCast(accessory.castValue, accessory);\r\n\t\t\t},\r\n\t\t}),\t\r\n\t\tnonPositiveInteger: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.nonPositiveNumber.validate(value);\r\n\t\t\t\tsj.Rule2.integer.validate(value);\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.nonPositiveNumber.validateCast(accessory.castValue, accessory);\r\n\t\t\t\tsj.Rule2.integer.validateCast(accessory.castValue, accessory);\r\n\t\t\t},\r\n\t\t}),\r\n\t\tpositiveInteger: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.positiveNumber.validate(value);\r\n\t\t\t\tsj.Rule2.integer.validate(value);\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.positiveNumber.validateCast(accessory.castValue, accessory);\r\n\t\t\t\tsj.Rule2.integer.validateCast(accessory.castValue, accessory);\r\n\t\t\t},\r\n\t\t}),\r\n\t\tnegativeInteger: new sj.Rule2({\r\n\t\t\tbaseValidate(value) {\r\n\t\t\t\tsj.Rule2.negativeNumber.validate(value);\r\n\t\t\t\tsj.Rule2.integer.validate(value);\r\n\t\t\t},\r\n\t\t\tbaseCast(accessory) {\r\n\t\t\t\tsj.Rule2.negativeNumber.validateCast(accessory.castValue, accessory);\r\n\t\t\t\tsj.Rule2.integer.validateCast(accessory.castValue, accessory);\r\n\t\t\t},\r\n\t\t}),\r\n\t}),\r\n});\r\n\r\n// SUCCESS //C success and error objects are returned from functions (mostly async ones)\r\nsj.Success = sj.Base.makeClass('Success', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// NEW\r\n\t\t\ttimestamp: undefined,\r\n\t\t},\r\n\t}),\t\r\n});\r\nsj.SuccessList = sj.Base.makeClass('SuccessList', sj.Success, {\r\n\tconstructorParts: parent => ({\r\n\t\t//C wrapper for an array of successful items\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\treason: 'all items successful',\r\n\t\t\tcontent: [],\r\n\t\t},\r\n\t}),\r\n});\r\nsj.Warn = sj.Base.makeClass('Warn', sj.Success, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\tlog: true,\r\n\t\t},\r\n\t}),\r\n});\r\n\r\nsj.Credentials = sj.Base.makeClass('Credentials', sj.Success, {\r\n\tconstructorParts: parent => ({\r\n\t\t//TODO allowUnknown: true,\r\n\r\n\t\tdefaults: {\r\n\t\t\t//TODO this part should only be server-side \r\n\t\t\t//TODO consider finding a way to delete these properties if they aren't passed in so that Object.assign() can work without overwriting previous values with empty defaults, at the moment im using a plain object instead of this class to send credentials\r\n\t\t\tauthRequestKey: Symbol(), //! this shouldn't break sj.checkKey(), but also shouldn't match anything\r\n\t\t\tauthRequestTimestamp: 0,\r\n\t\t\tauthRequestTimeout: 300000, //C default 5 minutes\r\n\t\t\tauthRequestURL: '',\r\n\t\t\tauthCode: Symbol(),\r\n\t\t\t\r\n\t\t\taccessToken: Symbol(),\r\n\t\t\texpires: 0,\r\n\t\t\trefreshToken: Symbol(),\r\n\t\t\trefreshBuffer:  60000, //C 1 minute //TODO figure out what the expiry time is for these apis and change this to a more useful value\r\n\t\t\t\r\n\t\t\tscopes: [],\r\n\t\t},\r\n\t}),\r\n});\r\n\r\n\r\n// ENTITIES\r\nsj.Entity = sj.Base.makeClass('Entity', sj.Success, {\r\n\tconstructorParts: parent => ({\r\n\t\tafterInitialize(accessory) {\r\n\t\t\tconst that = this; //? is this necessary?\r\n\t\t\tthis.filters = {};\r\n\t\t\tObject.keys(that.constructor.filters).forEach(key => {\r\n\t\t\t\tObject.defineProperties(that.filters, {\r\n\t\t\t\t\t[key]: {\r\n\t\t\t\t\t\tget: function () { \r\n\t\t\t\t\t\t\treturn sj.shake(that, that.constructor.filters[key]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t},\r\n\t\tdefaults: {\r\n\t\t\t// NEW\r\n\t\t\tid: undefined,\r\n\t\t},\r\n\t}),\r\n\tstaticProperties(parent) {\r\n\t\t// GETTER\r\n\t\tObject.defineProperty(this, 'table', {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn `${this.name.charAt(0).toLowerCase() + this.name.slice(1)}s`; //! lowercase, plural of name\r\n\t\t\t},\r\n\t\t}); \r\n\r\n\t\treturn {\r\n\t\t\t//TODO how to make these immutable?\r\n\r\n\t\t\t//C list of references to child classes, these should be added in the child's static constructor\r\n\t\t\tchildren: [],\r\n\r\n\t\t\tfilters: {\r\n\t\t\t\tid: ['id'],\r\n\t\t\t},\r\n\r\n\t\t\t//C automatically create new filters based on schema\r\n\t\t\tupdateFilters() {\r\n\t\t\t\tlet methodNames = ['add', 'get', 'edit', 'remove'];\r\n\t\t\t\tlet types = ['in', 'out', 'check'];\r\n\t\t\t\r\n\t\t\t\tlet schemaFilters = {};\r\n\t\t\t\r\n\t\t\t\tObject.keys(this.schema).forEach(key => { //C for each property\r\n\t\t\t\t\tmethodNames.forEach(methodName => { //C for each crud method\r\n\t\t\t\t\t\ttypes.forEach(type => { //C for each filter type\r\n\t\t\t\t\t\t\tif (this.schema[key][methodName][type]) { //C if property is optional or required\r\n\t\t\t\t\t\t\t\tlet filterName = methodName + type.charAt(0).toUpperCase() + type.slice(1); //C add it to the specific filter\r\n\t\t\t\t\t\t\t\tif (!schemaFilters[filterName]) schemaFilters[filterName] = [];\r\n\t\t\t\t\t\t\t\tschemaFilters[filterName].push(key);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\t\t\r\n\t\t\t\tthis.filters = {\r\n\t\t\t\t\t...this.filters,\r\n\t\t\t\t\t...schemaFilters,\r\n\t\t\t\t};\r\n\t\t\t},\r\n\r\n\t\t\ttableToEntity(tableName) {\r\n\t\t\t\tconst Entity = this.children.find(child => child.table === tableName);\r\n\t\t\t\tif (!sj.isType(new Entity(), sj.Entity)) throw new sj.Error({\r\n\t\t\t\t\torigin: 'sj.Entity.tableToEntity()',\r\n\t\t\t\t\treason: `table is not recognized: ${tableName}`,\r\n\t\t\t\t\tcontent: tableName,\r\n\t\t\t\t});\r\n\t\t\t\treturn Entity;\r\n\r\n\t\t\t\t//R get requests should be a raw object, not an sj.Entity, because the queries are sensitive to extra/default information\r\n\t\t\t\t//R any metadata (table) should be sent separately (or implicitly) from the query\r\n\t\t\t},\r\n\t\t}\r\n\t},\r\n});\r\n// schema property states //TODO could these be static on sj.Entity and called via this.x ?\r\nconst unused = {\r\n\tin: false,\r\n\tout: false,\r\n\tcheck: 0,\r\n};\r\nconst optional = {\r\n\tin: true,\r\n\tout: true,\r\n\tcheck: 1,\r\n};\r\nconst required = {\r\n\tin: true,\r\n\tout: true,\r\n\tcheck: 2,\r\n};\r\nconst auto = {\r\n\tin: false,\r\n\tout: true,\r\n\tcheck: 0,\r\n};\r\nsj.User = sj.Base.makeClass('User', sj.Entity, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// NEW\r\n\t\t\tname: '',\r\n\t\t\temail: '',\r\n\t\t\tpassword: '',\r\n\t\t\tpassword2: '',\r\n\t\t\tspotifyRefreshToken: null,\r\n\t\t\tsocketId: null,\r\n\t\t},\r\n\t}),\r\n\tstaticProperties(parent) {\r\n\t\tparent.children.push(this);\r\n\r\n\t\tthis.schema = {\r\n\t\t\t//G 0 = unused, 1 = optional, 2 = required\r\n\t\t\tid: {\r\n\t\t\t\tcolumnName: 'id',\r\n\t\t\t\trule: sj.Rule.id,\r\n\t\r\n\t\t\t\tadd: auto,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: required,\r\n\t\t\t\tremove: required,\r\n\t\t\t},\r\n\t\t\tname: {\r\n\t\t\t\tcolumnName: 'name',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'userNameRules',\r\n\t\t\t\t\tmessage: 'username validated',\r\n\t\t\t\t\ttarget: 'registerUserName',\r\n\t\t\t\t\tcssClass: 'inputError',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Username',\r\n\t\t\t\t\ttrim: true,\r\n\t\t\t\t\r\n\t\t\t\t\tmin: sj.Rule.nameMinLength,\r\n\t\t\t\t\tmax: sj.Rule.nameMaxLength,\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\temail: {\r\n\t\t\t\tcolumnName: 'email',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'emailRules',\r\n\t\t\t\t\tmessage: 'email validated',\r\n\t\t\t\t\ttarget: 'registerEmail',\r\n\t\t\t\t\tcssClass: 'inputError',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'E-mail',\r\n\t\t\t\t\ttrim: true,\r\n\t\t\t\t\r\n\t\t\t\t\tmin: 3,\r\n\t\t\t\t\tmax: sj.Rule.stringMaxLength,\r\n\t\t\t\t\r\n\t\t\t\t\t//TODO useFilter: ___, filterMessage: ___, \r\n\t\t\t\t\t//L https://stackoverflow.com/questions/46155/how-to-validate-an-email-address-in-javascript\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tpassword: {\r\n\t\t\t\tcolumnName: 'password',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'passwordRules',\r\n\t\t\t\t\tmessage: 'password validated',\r\n\t\t\t\t\ttarget: 'registerPassword',\r\n\t\t\t\t\tcssClass: 'inputError',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Password',\r\n\t\t\t\t\r\n\t\t\t\t\tmin: 6,\r\n\t\t\t\t\tmax: 72, //! as per bcrypt\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: unused,\r\n\t\t\t\tedit: {\r\n\t\t\t\t\tin: true,\r\n\t\t\t\t\tout: false,\r\n\t\t\t\t\tcheck: 1,\r\n\t\t\t\t},\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tspotifyRefreshToken: {\r\n\t\t\t\tcolumnName: 'spotifyRefreshToken',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'spotifyRefreshTokenRules',\r\n\t\t\t\t\tmessage: 'token validated',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Token',\r\n\t\t\t\t\t//TODO empty for now\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: unused,\r\n\t\t\t\tget: {\r\n\t\t\t\t\tin: false,\r\n\t\t\t\t\tout: true,\r\n\t\t\t\t\tcheck: 0,\r\n\t\t\t\t},\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t};\r\n\t\tthis.updateFilters();\r\n\t},\r\n});\r\nsj.Playlist = sj.Base.makeClass('Playlist', sj.Entity, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// OVERWRITE\r\n\t\t\tcontent: [], //? is this required to be an array, tracks aren't stored here anymore\r\n\t\r\n\t\t\t// NEW\r\n\t\t\tuserId: undefined,\r\n\t\t\tname: '',\r\n\t\t\tvisibility: '',\r\n\t\t\tdescription: '',\r\n\t\t\tcolor: '',\r\n\t\t\timage: '',\r\n\t\t},\r\n\t}),\r\n\tstaticProperties(parent) {\r\n\t\tparent.children.push(this);\r\n\r\n\t\tthis.schema = {\r\n\t\t\tid: {\r\n\t\t\t\tcolumnName: 'id',\r\n\t\t\t\trule: sj.Rule.id,\r\n\t\r\n\t\t\t\tadd: auto,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: required,\r\n\t\t\t\tremove: required,\r\n\t\t\t},\r\n\t\t\tuserId: {\r\n\t\t\t\tcolumnName: 'userId',\r\n\t\t\t\trule: sj.Rule.id,\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tname: {\r\n\t\t\t\tcolumnName: 'name',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'playlistNameRules()',\r\n\t\t\t\t\tmessage: 'name validated',\r\n\t\t\t\t\ttarget: 'playlistName',\r\n\t\t\t\t\tcssClass: 'inputError',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Name',\r\n\t\t\t\t\ttrim: true,\r\n\t\t\t\t\r\n\t\t\t\t\tmin: sj.Rule.nameMinLength,\r\n\t\t\t\t\tmax: sj.Rule.stringMaxLength,  \r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tdescription: {\r\n\t\t\t\tcolumnName: 'description',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'descriptionRules()',\r\n\t\t\t\t\tmessage: 'description validated',\r\n\t\t\t\t\ttarget: 'playlistDescription',\r\n\t\t\t\t\tcssClass: 'inputError',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Description',\r\n\t\t\t\t\r\n\t\t\t\t\tmax: sj.Rule.bigStringMaxLength,\r\n\t\t\t\t\ttrim: true,\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: optional,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tvisibility: {\r\n\t\t\t\tcolumnName: 'visibility',\r\n\t\t\t\trule: sj.Rule.visibility,\r\n\t\r\n\t\t\t\tadd: optional,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\timage: {\r\n\t\t\t\tcolumnName: 'image',\r\n\t\t\t\trule: sj.Rule.image,\r\n\t\r\n\t\t\t\tadd: optional,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tcolor: {\r\n\t\t\t\tcolumnName: 'color',\r\n\t\t\t\trule: sj.Rule.color,\r\n\t\r\n\t\t\t\tadd: optional,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t};\r\n\t\tthis.updateFilters();\r\n\t},\r\n});\r\nsj.Track = sj.Base.makeClass('Track', sj.Entity, {\r\n\tconstructorParts: parent => ({\r\n\t\tbeforeInitialize(accessory) {\r\n\t\t\t//C find existing source by track.source.name and set it as the reference\r\n\t\t\tif (sj.isType(accessory.options.source, Object)) {\r\n\t\t\t\tconst found = sj.Source.instances.find(source => source.name === accessory.options.source.name);\r\n\t\t\t\tif (found) accessory.options.source = found;\r\n\t\t\t\telse new sj.Warn({\r\n\t\t\t\t\torigin: 'sj.Track.beforeInitialize()',\r\n\t\t\t\t\treason: 'source was passed but it is not an existing source',\r\n\t\t\t\t\tcontent: accessory.options.source,\r\n\t\t\t\t});\r\n\t\t\t};\r\n\t\t},\r\n\t\tdefaults: {\r\n\t\t\t// NEW\r\n\t\t\tplaylistId:\tnull,\r\n\t\t\tposition:\tnull,\r\n\t\t\tsource:\t\tnull, //! before was sj.noSource, but this creates a circular reference error (only sometimes??)\r\n\t\t\tsourceId:\tnull, // TODO assumes ids are unique, even across all sources\r\n\t\t\tartists:\t[],\r\n\t\t\tname:\t\tnull,\r\n\t\t\tduration:\tnull, //! cannot be 0 or else it will not trigger sj.isEmpty() and will actually be set as 0\r\n\t\t\tlink:\t\tnull,\r\n\t\t},\r\n\t}),\r\n\tstaticProperties(parent) {\r\n\t\tparent.children.push(this);\r\n\r\n\t\tthis.schema = {\r\n\t\t\tid: {\r\n\t\t\t\tcolumnName: 'id',\r\n\t\t\t\trule: sj.Rule.id,\r\n\t\r\n\t\t\t\tadd: auto,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: required,\r\n\t\t\t\tremove: required,\r\n\t\t\t},\r\n\t\t\tplaylistId: {\r\n\t\t\t\tcolumnName: 'playlistId',\r\n\t\t\t\trule: sj.Rule.id,\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tposition: {\r\n\t\t\t\tcolumnName: 'position',\r\n\t\t\t\trule: sj.Rule.posInt,\r\n\t\r\n\t\t\t\tadd: optional,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tname: {\r\n\t\t\t\tcolumnName: 'name',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'trackNameRules()',\r\n\t\t\t\t\tmessage: 'name validated',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Name',\r\n\t\t\t\t\ttrim: true,\r\n\t\t\t\t\r\n\t\t\t\t\tmin: sj.Rule.nameMinLength,\r\n\t\t\t\t\tmax: sj.Rule.stringMaxLength,  \r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tduration: {\r\n\t\t\t\tcolumnName: 'duration',\r\n\t\t\t\trule: sj.Rule.posInt,\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tsource: {\r\n\t\t\t\tcolumnName: 'source',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'sourceRules',\r\n\t\t\t\t\tmessage: 'source validated',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Source',\r\n\t\t\t\t\r\n\t\t\t\t\tuseAgainst: false, //TODO sourceList isn't populated in global.js, but main.js\r\n\t\r\n\t\t\t\t\tcustom: function (value) {\r\n\t\t\t\t\t\treturn sj.Source.instances.some(source => value === source.name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tsourceId: {\r\n\t\t\t\tcolumnName: 'sourceId',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'sourceIdRules',\r\n\t\t\t\t\tmessage: 'source id validated',\r\n\t\t\t\t\r\n\t\t\t\t\tvalueName: 'Source ID',\r\n\t\t\t\t\r\n\t\t\t\t\t//? any source id rules (other than being a string)? length? trim?\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t},\r\n\t\t\tartists: {\r\n\t\t\t\tcolumnName: 'artists',\r\n\t\t\t\trule: new sj.Rule({\r\n\t\t\t\t\torigin: 'sj.Rules.artists',\r\n\t\t\t\t\tmessage: 'artists validated',\r\n\t\t\t\r\n\t\t\t\t\tvalueName: 'Artists',\r\n\t\t\t\r\n\t\t\t\t\tdataTypes: ['array'],\r\n\t\t\t\t}),\r\n\t\r\n\t\t\t\tadd: required,\r\n\t\t\t\tget: optional,\r\n\t\t\t\tedit: optional,\r\n\t\t\t\tremove: unused,\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.updateFilters();\r\n\r\n\t\t//G localMetadata is track properties that aren't derived from the source data, but instead created by the app or user. It must be preserved when using source data.\r\n\t\tthis.filters.localMetadata = ['id', 'playlistId', 'position'];\r\n\t},\r\n});\r\n\r\nsj.Source = sj.Base.makeClass('Source', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\t// NEW\r\n\t\t\tname: undefined, //! source.name is a unique identifier\r\n\t\t\tnullPrefix: '',\r\n\t\t\tidPrefix: '',\r\n\t\t\t\r\n\t\t\tcredentials: new sj.Credentials(),\r\n\t\r\n\t\t\t//TODO this should only be server-side\r\n\t\t\tapi: {},\r\n\t\t\tscopes: [],\r\n\t\t\tauthRequestManually: true,\r\n\t\t\tmakeAuthRequestURL: function () {},\r\n\t\t},\r\n\t\tafterInitialize(accessory) {\r\n\t\t\t//C add source to static source list: sj.Source.instances\r\n\t\t\tthis.constructor.instances.push(this);\r\n\t\t},\r\n\t}),\r\n\t\r\n\tstaticProperties: parent => ({\r\n\t\tinstances: [],\r\n\t\tfind(name) {\r\n\t\t\treturn this.instances.find(instance => instance.name === name);\r\n\t\t},\r\n\t}),\r\n});\r\n\r\n// LIVE DATA\r\nsj.LiveTable = sj.Base.makeClass('LiveTable', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\tEntity: undefined,\r\n\t\t},\r\n\t\tafterInitialize() {\r\n\t\t\tObject.assign(this, {\r\n\t\t\t\tliveQueries: [],\r\n\t\t\t\tcachedEntities: [],\r\n\t\t\t});\r\n\t\t},\r\n\t}),\r\n\tstaticProperties: parent => ({\r\n\t\tmakeTables(tableKeys) {\r\n\t\t\treturn new Map(sj.Entity.children.map(Entity => [Entity, new this({Entity})]));\r\n\t\t},\r\n\t}),\r\n});\r\nsj.CachedEntity = sj.Base.makeClass('CachedEntity', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\ttable: undefined,\r\n\t\t\tentity: undefined,\r\n\t\t},\r\n\t\tafterInitialize() {\r\n\t\t\tObject.assign(this, {\r\n\t\t\t\tliveQueryRefs: [],\r\n\r\n\t\t\t\ttimestamp: 0,\r\n\t\t\t});\r\n\t\t},\r\n\t}),\r\n});\r\nsj.LiveQuery = sj.Base.makeClass('LiveQuery', sj.Base, {\r\n\tconstructorParts: parent => ({\r\n\t\tbeforeInitialize(accessory) {\r\n\t\t\tif (sj.isType(accessory.options.query, Array)) accessory.options.query = sj.any(accessory.options.query);\r\n\t\t},\r\n\t\tdefaults: {\r\n\t\t\ttable: undefined,\r\n\t\t\tquery: undefined,\r\n\t\t},\r\n\t\tafterInitialize() {\r\n\t\t\tObject.assign(this, {\r\n\t\t\t\tcachedEntityRefs: [],\r\n\t\t\t\tsubscriptions: [],\r\n\r\n\t\t\t\ttimestamp: 0,\r\n\t\t\t});\r\n\t\t},\r\n\t}),\r\n});\r\nsj.Subscription = sj.Base.makeClass('Subscription', sj.Base, {\r\n\t//? should this inherit from sj.Success since it will be returned from a function>\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\tliveQuery: undefined,\r\n\r\n\t\t\tonUpdate() {}, //C any update\r\n\t\t\tonAdd() {}, //C entities added\r\n\t\t\tonEdit() {}, //C entities data changed\r\n\t\t\tonRemove() {}, //C entities removed\r\n\t\t},\r\n\t}),\r\n});\r\n\r\n\r\nexport default sj;\r\n\r\n\r\n//  \r\n//  \r\n//                \r\n//                \r\n//              \r\n//              \r\n\r\n//sj.deepMatch.test();\r\n//sj.shake.test();\r\n//sj.Base.test();","//      \r\n//   \r\n//             \r\n//            \r\n//        \r\n//           \r\n\r\n/*\r\n    //TODO consider just writing native api functions, because they are fairly simple, and the spotify-web-api-node\r\n    //L https://beta.developer.spotify.com/documentation/general/guides/authorization-guide/\r\n\r\n    //TODO remove exports. from internal functions\r\n\r\n*/\r\n\r\n//       \r\n//  \r\n//                \r\n//                \r\n//        \r\n//             \r\n\r\n/*\r\n*/\r\n\r\n\r\n//            \r\n//      \r\n//                     \r\n//                    \r\n//         \r\n//              \r\n\r\n// builtin\r\nimport EventEmitter from 'events';\r\n\r\n// external\r\n//import btoa from 'btoa';\r\nimport SpotifyWebApi from 'spotify-web-api-node'; //L https://github.com/thelinmichael/spotify-web-api-node\r\n \r\n// internal\r\nimport sj from './global-server.mjs';\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//          \r\n\r\n// events\r\nconst emitter = new EventEmitter();\r\n\r\nlet auth = {};\r\n\r\n//         \r\n//       \r\n//           \r\n//           \r\n//            \r\n//              \r\n\r\n//C generics\r\nauth.requestTimeout = 300000; //C 5 minutes\r\nauth.requestKeys = [];\r\nauth.addRequestKey = async function () {\r\n    return await sj.addKey(this.requestKeys, this.requestTimeout);\r\n};\r\nauth.checkRequestKey = async function (key) {\r\n    let pack =  await sj.checkKey(this.requestKeys, key);\r\n    return {authRequestKey: pack.key, authRequestTimestamp: pack.timestamp};\r\n};\r\n\r\n\r\n//         \r\n//     \r\n//               \r\n//               \r\n//    \r\n//         \r\n\r\n//TODO consider moving this over to the globals-server stuff\r\n//C this is only used in auth.startAuthRequest() for its spotify.makeAuthRequestURL() function\r\nsj.spotify = new sj.Source({\r\n\tname: 'spotify',\r\n    api: new SpotifyWebApi({\r\n        //C create api object and set credentials in constructor\r\n        clientId: process.env.SPOTIFY_CLIENT_ID,\r\n        clientSecret: process.env.SPOTIFY_CLIENT_SECRET,\r\n        redirectUri: process.env.SPOTIFY_REDIRECT_URI,\r\n    }),\r\n    get scopes() { //? why does this need to be a getter?, i think it was because one of the properties needed to be dynamic and react to authRequestManually\r\n        return [\r\n            /* //C\r\n            contains an array of all scopes sent with the auth request\r\n        \r\n            'streaming', 'user-read-birthdate', 'user-read-email', 'user-read-private' are required for the web playback sdk\r\n            'user-modify-playback-state' is required to operate the playback\r\n        \r\n            show_dialog sets whether or not to force the user to approve the request each time\r\n            \r\n            state gets returned back with the request, TODO use with hashes to verfy that the response came from the expected source\r\n            */\r\n        \r\n            // users\r\n            'user-read-private',\r\n            'user-read-email',\r\n            'user-read-birthdate',\r\n            \r\n            // spotify connect\r\n            'user-read-currently-playing',\r\n            'user-modify-playback-state',\r\n            'user-read-playback-state',\r\n        \r\n            // streaming\r\n            'streaming',\r\n        ];\r\n    },\r\n    authRequestManually: true,\r\n    makeAuthRequestURL: function (key) {\r\n\t\t//TODO make a better catch & handle, this is a temporary catch for undefined credentials as the error is silent until it arrives on spotify's end: 'Missing required parameter: client_id'\r\n\t\tif (!sj.isType(this.api._credentials.clientId, String) ||\r\n\t\t!sj.isType(this.api._credentials.clientSecret, String) ||\r\n\t\t!sj.isType(this.api._credentials.redirectUri, String)) {\r\n            throw new sj.Error({\r\n                log: true,\r\n                origin: 'spotify.makeAuthRequestURL()',\r\n                message: 'one or more api credentials are missing or of the wrong type',\r\n                content: {\r\n                    clientId: this.api._credentials.clientId,\r\n                    clientSecret: this.api._credentials.clientSecret,\r\n                    redirectUri: this.api._credentials.redirectUri,\r\n                }\r\n            });\r\n        }\r\n\r\n        //! the show_dialog query parameter isn't available in the createAuthorizeURL, so it is manually added\r\n        return this.api.createAuthorizeURL(this.scopes, key) + `&show_dialog=${this.authRequestManually}`;\r\n    },\r\n});\r\n//TODO make any property available for sj.Source\r\nObject.assign(sj.spotify, {\r\n\tstartAuthRequest: async function () {\r\n\t\tlet pack = await auth.addRequestKey();\r\n\t\treturn new sj.Credentials({\r\n\t\t\tauthRequestKey: pack.key,\r\n\t\t\tauthRequestTimestamp: pack.timestamp,\r\n\t\t\tauthRequestTimeout: pack.timeout,\r\n\t\t\tauthRequestURL: this.makeAuthRequestURL(pack.key),\r\n\t\t});\r\n\t},\r\n\treceiveAuthRequest: async function (query) {\r\n\t\t//C receives and transforms credentials from spotify after the user confirms the authorization\r\n\t\t/*//C spotify authorization guide\r\n\t\t\t//L https://developer.spotify.com/documentation/general/guides/authorization-guide/\r\n\r\n\t\t\tif the user accepts the request:\r\n\t\t\tcode\tAn authorization code that can be exchanged for an access token.\r\n\t\t\tstate\tThe value of the state parameter supplied in the request.\r\n\r\n\t\t\tif the user denies the request, or if an error has occured\r\n\t\t\terror\tThe reason authorization failed, for example: access_denied \r\n\t\t\tstate\tThe value of the state parameter supplied in the request.\r\n\r\n\t\t\t//TODO create error parser for spotify api\r\n\t\t*/\r\n\r\n\t\t//C ensure key is recognized, if its not (or timed out), nothing can be done, let it timeout on the client side too\r\n\t\tawait auth.checkRequestKey(query.state);\r\n\t\t//C ensure that spotify sent the code\r\n\t\tif (sj.isType(query.code, undefined)) {\r\n\t\t\temitter.emit(query.state, new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'receiveAuthRequest()',\r\n\t\t\t\tmessage: 'spotify authorization failed',\r\n\t\t\t\treason: 'code is missing',\r\n\t\t\t\tcontent: query,\r\n\t\t\t}));\r\n\t\t}\r\n\t\t//C ensure that spotify didn't send an error\r\n\t\tif (!sj.isType(query.error, undefined)) {\r\n\t\t\temitter.emit(query.state, new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\torigin: 'receiveAuthRequest()',\r\n\t\t\t\tmessage: 'spotify authorization failed',\r\n\t\t\t\treason: query.error,\r\n\t\t\t\tcontent: query,\r\n\t\t\t}));\r\n\t\t}\r\n\r\n\t\t//C send the event and credentials for endAuthRequest() to pick up\r\n\t\temitter.emit(query.state, new sj.Credentials({ //? sj.success here?\r\n\t\t\tauthRequestKey: query.state, //? is this needed anymore?\r\n\t\t\tauthCode: query.code,\r\n\t\t}));\r\n\t},\r\n\tendAuthRequest: async function (credentials) {\r\n\t\t//C catches events emitted by receiveAuthRequest() and sends them to the waiting router request\r\n\r\n\t\treturn await new Promise((resolve, reject) => { //! needs to be a promise wrapper because emitter.once uses a callback function\r\n\t\t\t//C setup listener for authRequestKey\r\n\t\t\temitter.once(credentials.authRequestKey, (result) => {\r\n\t\t\t\tresolve(result);\r\n\t\t\t});\r\n\r\n\t\t\t//C setup timeout\r\n\t\t\tsj.wait(credentials.authRequestTimeout).then(() => {\r\n\t\t\t\treject(new sj.Error({\r\n\t\t\t\t\tlog: true,\r\n\t\t\t\t\torigin: 'sj.spotify.endAuthRequest()',\r\n\t\t\t\t\tmessage: 'request timeout',\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\t\t});\r\n\t},\r\n\texchangeToken: async function (ctx, credentials) {\r\n\t\t//C exchange auth code for access and refresh tokens\r\n\t\t//C exchangeToken() is only outside of endAuthRequest() because the auth window should close and not have to wait for the exchange to happen - to reduce flickering of the redirect page\r\n\r\n\t\t//C grab timestamp before sending request so that the recorded expiry time is before the actual expiry time\r\n\t\tlet timestamp = Date.now();\r\n\t\t//C exchange the auth code for tokens\r\n\t\t//L https://developer.spotify.com/documentation/general/guides/authorization-guide/\r\n\t\tlet result = await sj.request('POST', 'https://accounts.spotify.com/api/token', sj.encodeProps({\r\n\t\t\tgrant_type: 'authorization_code',\r\n\t\t\tcode: credentials.authCode,\r\n\t\t\tredirect_uri: process.env.SPOTIFY_REDIRECT_URI, //C only used for validation, no need to make a second redirect handler\r\n\r\n\t\t\tclient_id: process.env.SPOTIFY_CLIENT_ID,\r\n\t\t\tclient_secret: process.env.SPOTIFY_CLIENT_SECRET,\r\n\t\t\t// alternative to client_id and client_secret properties, put this in header: 'Authorization': `Basic ${btoa(`${process.env.SPOTIFY_CLIENT_ID}:${process.env.SPOTIFY_CLIENT_SECRET}`)}`,\r\n\t\t}), sj.URL_HEADER).catch(rejected => {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\tmessage: 'failed to authorize spotify',\r\n\t\t\t\treason: 'token exchange failed',\r\n\t\t\t\tcontent: rejected,\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\t//C store refresh token in database\r\n\t\t//C while the client triggers the refresh of the accessToken (so that the server doesn't have to keep track of which users are online), the refreshToken is stored server side so that the user doesn't have to re-auth between sessions\r\n\t\tlet me = await sj.session.get(ctx).then(sj.content);\r\n\t\tawait sj.User.edit({id: me.id, spotifyRefreshToken: result.refresh_token}).then(resolved => {\r\n\t\t});\r\n\r\n\t\t//C repack and return\r\n\t\treturn new sj.Credentials({\r\n\t\t\taccessToken: result.access_token,\r\n\t\t\texpires: timestamp + result.expires_in,\r\n\t\t\t//refreshToken: result.refresh_token,\r\n\t\t\tscopes: result.scope.split(' '),\r\n\t\t\t//C result.token_type is the only omitted property, this is always 'Bearer'\r\n\t\t});\r\n\t},\r\n\trefreshToken: async function (ctx) {\r\n\t\t//C get the refresh token from the database\r\n\t\tlet me = await sj.session.get(ctx).then(sj.content);\r\n\t\tlet refreshToken = await sj.User.get(me).then(sj.content).then(sj.one).then(resolved => resolved.spotifyRefreshToken);\r\n\r\n\t\t//C if there isn't one, throw the specific AuthRequired error, this will be identified on the client side and trigger spotify.auth()\r\n\t\tif (sj.isEmpty(refreshToken)) {\r\n\t\t\tthrow new sj.AuthRequired();\r\n\t\t}\r\n\r\n\t\t//C send a refresh request to spotify to get new access token, expiry time, and possible refresh token\r\n\t\tlet timestamp = Date.now();\r\n\t\tlet result = await sj.request('POST', 'https://accounts.spotify.com/api/token', sj.encodeProps({\r\n\t\t\tgrant_type: 'refresh_token',\r\n\t\t\trefresh_token: refreshToken,\r\n\t\t\t\r\n\t\t\tclient_id: process.env.SPOTIFY_CLIENT_ID,\r\n\t\t\tclient_secret: process.env.SPOTIFY_CLIENT_SECRET,\r\n\t\t}), sj.URL_HEADER).catch(rejected => {\r\n\t\t\tthrow new sj.Error({\r\n\t\t\t\tlog: true,\r\n\t\t\t\tmessage: 'failed to authorize spotify',\r\n\t\t\t\treason: 'token refresh failed',\r\n\t\t\t\tcontent: rejected,\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\t//C if a new refresh token was sent\r\n\t\tif (sj.isType(result.refresh_token, 'string')) { //? better validation?\r\n\t\t\t//C store it\r\n\t\t\tawait sj.User.edit({id: me.id, spotifyRefreshToken: result.refresh_token});\t\r\n\t\t}\r\n\t\t\r\n\t\t//C send only the accessToken and the expiry time\r\n\t\treturn new sj.Credentials({\r\n\t\t\torigin: 'sj.spotify.refreshToken()',\r\n\t\t\taccessToken: result.access_token,\r\n\t\t\texpires: timestamp + result.expires_in,\r\n\t\t});\r\n\t},\r\n});\r\n\r\n\r\nsj.youtube = new sj.Source({\r\n\tname: 'youtube',\r\n});\r\nObject.assign(sj.youtube, {\r\n\tgetCredentials: async function () {\r\n\t\treturn {\r\n\t\t\tapiKey: process.env.YOUTUBE_API_KEY,\r\n\t\t\tclientId: process.env.YOUTUBE_CLIENT_ID,\r\n\t\t};\r\n\t},\r\n});\r\n\r\nexport default auth;","//            \r\n//      \r\n//                     \r\n//                    \r\n//         \r\n//              \r\n\r\n// builtin\r\n\r\n// external\r\nimport pgpF from 'pg-promise';\r\nconst pgp = pgpF({\r\n    //TODO initialization options here: //L http://vitaly-t.github.io/pg-promise/module-pg-promise.html\r\n});\r\n\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//          \r\n\r\nconst config = {\r\n    // https://github.com/vitaly-t/pg-promise/wiki/Connection-Syntax#configuration-object\r\n    // TODO create new db user with restricted capabilities\r\n    host: process.env.DB_HOST || 'localhost',\r\n    port: process.env.DB_PORT || '5432',\r\n    database: process.env.DB_NAME || 'test',\r\n    user: process.env.DB_USERNAME || 'postgres',\r\n    password: process.env.DB_PASSWORD || 'pgPassword',\r\n}\r\nconst db = pgp(config);\r\n\r\n\r\n//C create a single db object for entire app\r\nexport default db;\r\nexport {pgp};\r\n\r\n\r\nconst schema = {\r\n\tname: 'sj',\r\n\ttables: {\r\n\t\tusers: {\r\n\t\t\tname: 'users',\r\n\t\t\tcolumns: {\r\n\t\t\t\tid: {\r\n\t\t\t\t\tname: 'id',\r\n\t\t\t\t},\r\n\t\t\t\tname: {\r\n\t\t\t\t\tname: 'name',\r\n\t\t\t\t},\r\n\t\t\t\tpassword: {\r\n\t\t\t\t\tname: 'password',\r\n\t\t\t\t},\r\n\t\t\t\temail: {\r\n\t\t\t\t\tname: 'email',\r\n\t\t\t\t},\r\n\t\t\t\tspotifyRefreshToken: {\r\n\t\t\t\t\tname: 'spotify_refresh_token',\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t},\r\n\t},\r\n};","//      \r\n//   \r\n//             \r\n//            \r\n//        \r\n//           \r\n\r\n/*\r\n    //G CRUD MAP\r\n    Create = add\r\n    Retrieve = get\r\n    Update = edit\r\n    Delete = remove\r\n\r\n    //R CRUD DATA FORMAT\r\n\t\tget functions will be allowed to get multiple resources (just a simple query based on matches), for example getting a playlist with only userId will get all playlists by that user\r\n\t\t\r\n\t\tthere is some confusion about what is 'known' information - because playlists hold data on the tracks they contain, but users don't hold data on the playlists they have. get needs the ability for multiple matches because it is not 'known' by the client what it contains (playlist is only able to do this because the multiple query is done manually server-side when getting the original playlist, this is not done for user)\r\n\t\r\n\t\ttwo directions - either make user retrieve all of it's containing playlists (lots of data being passed around here, no way to do a different query for playlists or tracks separated from user), or allow multiple querying (creates a difference between get and the other CRUD methods (add, edit, and remove could be done in multiple but these are all methods where the client 'knows' the exact resource they're manipulating and can be done iteratively on the client-side)\r\n\t\r\n\t\tmaybe make all CRUD methods multiply possible (for admin stuff? remove all tracks in a playlist (at once) without doing them iteratively client-side), all of these would have to fail if any one part fails (using that postgres thing (transaction commit?))\r\n\r\n\t\tall CRUD will return an array of any number of rows\r\n\r\n\t\tGET should be the only method used for search/query. EDIT & DELETE (& ADD) should not, therefore, editing or deleting a resource should only be done when it's id is known (after probably GETing it), (this clears up confusion: say we want to edit a track where its property is x, this is done in the GET method, but here is an issue when determining what data is the replacement data and what data is the query data - therefore only the id should be used as the query data (because it cant be changed), an the rest is the replacement data)\r\n\r\n\t\tbecause of this it becomes: get | add, edit, remove   or   get, remove | add, edit    (because it could make sense for remove to query too because it doesn't have replacement data, but not add because it doesn't need a query), it comes down to consistency, get could take a single object, add, edit, remove, could take an array of objects (and return single success/failure?), what about get taking an array and returning an array\r\n\t\t\r\n\t\t//L multiple resources with one request: https://stackoverflow.com/questions/32098423/rest-updating-multiple-resources-with-one-request-is-it-standard-or-to-be-avo\r\n\r\n\r\n\t//R sj.ErrorList\r\n\t\tErrorList should not be a wrapper for a list of errors, ErrorList should be a version of a single error that has multiple 'parallel' parts (ie: adding a user and having an issue with multiple fields - its still a single error with one resource (a user) but there are multiple parts to the error that need to be evaluated in parallel not in sequence)\r\n\t\t\r\n\t\twould this not mean that requests are also evaluated in parallel? that response arrays should all have Success or ErrorList wrappers?, wouldn't this be redundant - if everything is already an array why have a wrapper for it? what would be the default wrapper for request data like editTracks([{}, {}, ...]) ?\r\n\r\n\t//G JAVASCRIPT GUIDELINES\r\n\t\twhen returning a promise / async function, use return await Promise()\r\n\t\t//L https://stackoverflow.com/questions/38708550/difference-between-return-await-promise-and-return-promise\r\n\t\t//L https://www.reddit.com/r/javascript/comments/7idasp/await_vs_return_vs_return_await/ \r\n\t\t\r\n\t\t//L proper use of array methods: https://medium.com/front-end-weekly/stop-array-foreach-and-start-using-filter-map-some-reduce-functions-298b4dabfa09\r\n\t\r\n\t//R CLASS NAMESPACES\r\n\t\tI started using Object.assign() to supplement sj.Entity (and other classes) for server-specific functionality, however it was limiting me to shallow assignment - which required a bunch of functions to have prefixes (addPrepare, getPrepare, etc.), and I really wanted to avoid calling these functions like: this[`${method}Prepare`](), I wanted functional assignment much like class constructors, so I decided to switch to using  (function () {}).call()  which acts kind of reverse to how its used as 'super' in function classes, basically calling another constructor(?) later\r\n\t\t\r\n\t\ttwo ways to implement: namespace within the class - this requires those namespaced functions to be called via this.namespace.fn.call(this, ...), or just prefix the functions which requires them to be called via this[`${namespace}Fn`](...), still not sure which is better\r\n\t\t\r\n\t\tactually - don't do that namespace thing, as the namespace is still a reference to an object, so if a child class changes one of its properties, it changes it for all classes with that same namespace\r\n\r\n\t//G FUNCTION MODIFICATION VS RETURN NEW\r\n\t\tmodifying & returning passed objects in functions, in general I'm deciding to modify passed objects in functions and return the same reference, however when the data-structure changes (nesting, cloning, etc.), the passed object should not be modified. this can be seen in sj.Entity.common() validation, where any nested validated properties are flattened into a root object\r\n*/\r\n\r\n\r\n//       \r\n//  \r\n//                \r\n//                \r\n//        \r\n//              \r\n\r\n/*\r\n\t// PRODUCTION\r\n\t\ttree-shake any objects that don't need to be exported (remove from sj.x, just hae them locally defined)\r\n\t\tafter functions are mostly debugged - remove a lot of the .catch(sj.propagate) - this is mainly tracing and unhandled error\r\n\r\n\t// BEST PRACTICE\r\n\t\t//L best practices: https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api\r\n\t\t//L review common pg-promise mistakes: https://github.com/vitaly-t/pg-promise/wiki/Common-Mistakes#invalid-query-formatting-with-manual-string-concatenation-and-es6-template-strings\r\n\r\n\t// SECURITY\r\n\r\n\t\tissue for private query variables (eg password), if someone queries for users where password = x, the passwords wont be returned, but they will still receive a list of users that that query matches\r\n\r\n\t\t//? user id being in the session.user object is basically the user's access key -> how do I ensure this is secure too? (aside from using a secure connection), it has to do with koa-session and how the session keys work - figure this out - I think this info is never sent to the client, just stored in the server and accessed via cookie key\r\n\t\t\r\n\t\tpermissions: [admin, self, password, link, public, etc.]\r\n\r\n\t\ttrack names that don't fit the requirements (too short, too long, etc. will throw an error when trying to add, this isn't desirable because all the track names will be external) should use casting if those restrictions are necesary\r\n\r\n\t// CONSIDER\r\n    \tdelegating unexpected error catches to only top-level entry points, (so that catchUnexpected() doesn't have to be repeated for every single \r\n\r\n\t// GENERAL\r\n\t\t//! IMPORTANT //! check any CRUD functions (like addTrack()) that rely on the current state of the database for information - because asyncForEach() functions are executed in parallel, and not in series, this could cause collisions\r\n\t\treplace all database variables, column names, etc. with constants inside this file (or the db file)\r\n*/\r\n\r\n\r\n//            \r\n//      \r\n//                     \r\n//                    \r\n//         \r\n//               \r\n\r\n// builtin\r\n\r\n// external\r\nimport fetch from 'node-fetch'; //C global.mjs uses fetch\r\nimport bcrypt from 'bcryptjs';\r\n\r\n// internal\r\nimport sj from '../public/js/global.mjs';\r\nimport database, {pgp} from './db.mjs';\r\nimport liveData from './live-data-server.mjs';\r\n\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//           \r\n\r\nsj.fetch = fetch;\r\n\r\n// BCRYPT\r\nconst saltRounds = 10; \r\n\r\n// DATABASE\r\nsj.db = database; //C for use of db with globals so that db doesn't have to be imported twice\r\n\r\n// LIVE DATA\r\nsj.liveData = liveData;\r\n\r\n\r\n//          \r\n//          \r\n//                \r\n//                \r\n//        \r\n//           \r\n\r\n// POSTGRES\r\n//? this should be called once on startup, where should this go?\r\n(async () => {\r\n\t/*\r\n\t\tconst schema = {\r\n\t\t\tname: 'sj',\r\n\t\t\ttables: {\r\n\t\t\t\tusers: {\r\n\t\t\t\t\tname: 'users',\r\n\t\t\t\t\tcolumns: {\r\n\t\t\t\t\t\tid: {\r\n\t\t\t\t\t\t\tname: 'id',\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tname: {\r\n\t\t\t\t\t\t\tname: 'name',\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tpassword: {\r\n\t\t\t\t\t\t\tname: 'password',\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\temail: {\r\n\t\t\t\t\t\t\tname: 'email',\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tspotifyRefreshToken: {\r\n\t\t\t\t\t\t\tname: 'spotifyRefreshToken',\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t};\r\n\t*/\r\n\r\n    // initialize\r\n    return sj.db.tx(async function (t) {\r\n        // TODO this will not alter tables if they do already exist (save this for migration)\r\n        \r\n        // schema: https://www.postgresql.org/docs/9.3/static/sql-createschema.html\r\n        // constraints: https://www.postgresql.org/docs/9.4/static/ddl-constraints.html\r\n        // foreign keys - REFERENCES otherTable (column) *if the column is omitted then the primary key of the referenced table is used\r\n        // ON DELETE CASCADE also removes any referencing rows when the referenced row is removed\r\n        // TODO CHECK constraint that visibility, source matches possible  states\r\n        // quotes: https://stackoverflow.com/questions/41396195/what-is-the-difference-between-single-quotes-and-double-quotes-in-postgresql\r\n        \r\n        // default constraint names: https://stackoverflow.com/questions/4107915/postgresql-default-constraint-names\r\n\r\n        if (false) {\r\n            await t.none(`DROP SCHEMA IF EXISTS \"sj\" CASCADE`).catch(rejected => {\r\n                throw new sj.Error({\r\n                    log: true,\r\n                    origin: 'schema initialization',\r\n                    message: 'database error',\r\n                    reason: rejected.message,\r\n                    content: rejected,\r\n                    target: 'notify',\r\n                    cssClass: 'notifyError',\r\n                });\r\n            });\r\n        }\r\n\r\n        // TODO add self, public, & private VIEWs for tables (if relevant)\r\n        // !!!  remember to add error messages for constraint violations to parsePostgresError() in functions.js\r\n        // !!! column names are camelCase (because they get converted to properties), everything else is underscore\r\n        return t.none(`CREATE SCHEMA IF NOT EXISTS \"sj\"`).catch(rejected => {\r\n            throw new sj.Error({\r\n                log: true,\r\n                origin: 'schema initialization',\r\n                message: 'database error',\r\n                reason: rejected.message,\r\n                content: rejected,\r\n                target: 'notify',\r\n                cssClass: 'notifyError',\r\n            });\r\n        }).then(resolved => {\r\n\t\t\t// https://www.postgresql.org/docs/9.1/static/sql-createtable.html\r\n\t\t\t//! spotifyRefreshToken is specifically pascal case to match object property names\r\n            return t.none(`CREATE TABLE IF NOT EXISTS \"sj\".\"users\" (\r\n\t\t\t\t\"id\" SERIAL CONSTRAINT \"users_id_pkey\" PRIMARY KEY,\r\n                \"name\" text CONSTRAINT \"users_name_key\" UNIQUE,\r\n                \"password\" text,\r\n\t\t\t\t\"email\" text CONSTRAINT \"users_email_key\" UNIQUE,\r\n\t\t\t\t\"spotifyRefreshToken\" text\r\n            );`).catch(rejected => {\r\n                throw new sj.Error({\r\n                    log: true,\r\n                    origin: 'users table initialization',\r\n                    message: 'database error',\r\n                    reason: rejected.message,\r\n                    content: rejected,\r\n                    target: 'notify',\r\n                    cssClass: 'notifyError',\r\n                });\r\n            });\r\n        }).then(resolved => {\r\n            //L views: https://www.postgresql.org/docs/8.1/static/tutorial-views.html\r\n            //L create or replace: https://stackoverflow.com/questions/48662843/what-is-the-equivalent-of-create-view-if-not-exists-in-postresql\r\n            return t.none(`CREATE OR REPLACE VIEW \"sj\".\"users_self\" AS\r\n                SELECT id, name, email \r\n                FROM \"sj\".\"users\"\r\n            ;`).catch(rejected => {\r\n                throw new sj.Error({\r\n                    log: true,\r\n                    origin: 'users_self initialization',\r\n                    message: 'database error',\r\n                    reason: rejected.message,\r\n                    content: rejected,\r\n                    target: 'notify',\r\n                    cssClass: 'notifyError',\r\n                });\r\n            });\r\n        }).then(resolved => {\r\n            return t.none(`CREATE OR REPLACE VIEW \"sj\".\"users_public\" AS\r\n                SELECT id, name\r\n                FROM \"sj\".\"users\"\r\n            ;`).catch(rejected => {\r\n                throw new sj.Error({\r\n                    log: true,\r\n                    origin: 'users_public initialization',\r\n                    message: 'database error',\r\n                    reason: rejected.message,\r\n                    content: rejected,\r\n                    target: 'notify',\r\n                    cssClass: 'notifyError',\r\n                });\r\n            });\r\n        }).then(resolved => {\r\n            return t.none(`CREATE TABLE IF NOT EXISTS \"sj\".\"playlists\" (\r\n                \"id\" SERIAL CONSTRAINT \"playlists_id_pkey\" PRIMARY KEY,\r\n                \"userId\" integer CONSTRAINT \"playlists_userId_fkey\" REFERENCES \"sj\".\"users\" ON DELETE CASCADE ON UPDATE CASCADE,\r\n                \"name\" text,\r\n                \"visibility\" text,\r\n                \"description\" text,\r\n                \"image\" text,\r\n                \"color\" text,\r\n                \r\n                CONSTRAINT \"playlists_userId_name_key\" UNIQUE (\"userId\", \"name\")\r\n            );`).catch(rejected => {\r\n                throw new sj.Error({\r\n                    log: true,\r\n                    origin: 'playlists table initialization',\r\n                    message: 'database error',\r\n                    reason: rejected.message,\r\n                    content: rejected,\r\n                    target: 'notify',\r\n                    cssClass: 'notifyError',\r\n                });\r\n            });\r\n        }).then(resolved => {\r\n            return t.none(`CREATE TABLE IF NOT EXISTS \"sj\".\"tracks\" (\r\n                \"id\" SERIAL CONSTRAINT \"tracks_id_pkey\" PRIMARY KEY,\r\n                \"playlistId\" integer CONSTRAINT \"tracks_playlistId_fkey\" REFERENCES \"sj\".\"playlists\" ON DELETE CASCADE ON UPDATE CASCADE,\r\n                \"position\" integer,\r\n                \"source\" text,\r\n                \"sourceId\" text,\r\n                \"name\" text,\r\n                \"duration\" integer,\r\n                \"artists\" text ARRAY DEFAULT ARRAY[]::text[],\r\n\r\n                CONSTRAINT \"tracks_playlistId_position_key\" UNIQUE (\"playlistId\", \"position\") DEFERRABLE INITIALLY IMMEDIATE \r\n            );`).catch(rejected => {\r\n                throw new sj.Error({\r\n                    log: true,\r\n                    origin: 'tracks table initialization',\r\n                    message: 'database error',\r\n                    reason: rejected.message,\r\n                    content: rejected,\r\n                    target: 'notify',\r\n                    cssClass: 'notifyError',\r\n                });\r\n            });\r\n        }).catch(rejected => {\r\n            throw sj.propagate(rejected);\r\n        });\r\n    }).catch(rejected => {\r\n        throw sj.propagate(rejected);\r\n    });\r\n})().then(resolved => {\r\n    new sj.Success({\r\n        origin: 'initialize database',\r\n        message: 'database initialized',\r\n    });\r\n}).catch(rejected => {\r\n    console.log(rejected);\r\n});\r\n\r\nsj.parsePostgresError = function (pgError, sjError) {\r\n    //TODO any validation needed here?\r\n    //TODO consider separating insertion checks into Conditions so multiple parameters are checked\r\n    //TODO add targets and cssClasses to each violation case too\r\n\r\n    sjError.code = pgError.code;\r\n    sjError.reason = pgError.message;\r\n    sjError.content = pgError;\r\n\r\n    // https://www.postgresql.org/docs/9.6/static/errcodes-appendix.html\r\n\r\n    // Class 23  Integrity Constraint Violation\r\n    if (pgError.code === '23505') { // unique_violation\r\n        // users\r\n        if (pgError.constraint === 'users_name_key') {\r\n            sjError.message = 'this user name is already taken';\r\n        }\r\n        if (pgError.constraint === 'users_email_key') {\r\n            sjError.message = 'this email is already in use';\r\n        }\r\n        // playlists\r\n        if (pgError.constraint === 'playlists_userId_name_key') {\r\n            sjError.message = 'you already have a playlist with this name';\r\n        }\r\n        // tracks\r\n        if (pgError.constraint === 'tracks_position_key') {\r\n            sjError.message = 'a track already exists at this position';\r\n        }\r\n    }\r\n\r\n    if (pgError.code === '23503') { // foreign_key_violation\r\n        // playlists\r\n        if (pgError.constraint === 'playlists_userId_fkey') {\r\n            sjError.message = 'cannot add a playlist for an unknown user';\r\n        }\r\n        // tracks\r\n        if (pgError.constraint === 'tracks_playlistId_fkey') {\r\n            sjError.message = 'cannot add a track for an unknown playlist';\r\n        }\r\n    }\r\n\r\n    sjError.announce();\r\n    return sjError;\r\n}\r\n\r\n\r\nsj.buildValues = function (mappedEntity) {\r\n\tif (Object.keys(mappedEntity).length === 0) {\r\n\t\t//C this shouldn't insert anything\r\n\t\treturn `(\"id\") SELECT 0 WHERE 0 = 1`;\r\n\t} else {\r\n\t\tlet columns = [];\r\n\t\tlet values = [];\r\n\t\tlet placeholders = [];\r\n\r\n\t\tObject.keys(mappedEntity).forEach((key, i) => {\r\n\t\t\tcolumns.push(key);\r\n\t\t\tvalues.push(mappedEntity[key]);\r\n\t\t\tplaceholders.push(`$${i+1}`); //C $1 based placeholders\r\n\t\t});\r\n\r\n\t\tcolumns = columns.join('\", \"'); //C inner delimiter\r\n\t\tcolumns = `(\"${columns}\")`; //C outer\r\n\r\n\t\tplaceholders = placeholders.join(', ');\r\n\t\tplaceholders = `(${placeholders})`;\r\n\r\n\t\t//? this should be able to format arrays just as any other value, otherwise the format is: ARRAY[value1, value2, ...]\r\n\t\treturn pgp.as.format(`${columns} VALUES ${placeholders}`, values);\r\n\t}\r\n};\r\nsj.buildWhere = function (mappedEntity) {\r\n\tif (Object.keys(mappedEntity).length === 0) { //TODO hacky\r\n\t\t//C return a false clause\r\n\t\treturn '0 = 1';\r\n\t} else {\r\n\t\t//C pair as formatted string\r\n\t\tlet pairs = [];\r\n\t\tpairs = Object.keys(mappedEntity).map(key => {\r\n\t\t\t//C wrap array in another array so that pgp doesn't think its values are for separate placeholders\r\n\t\t\tlet input = sj.isType(mappedEntity[key], Array) ? [mappedEntity[key]] : mappedEntity[key];\r\n\t\t\treturn pgp.as.format(`\"${key}\" = $1`, input); //! if the value here is undefined, it wont format, it will simply leave the string as '\"key\" = $1'\r\n\t\t});\r\n\r\n\t\t//C join with ' AND '\r\n\t\treturn pairs.join(' AND ');\r\n\t}\r\n};\r\nsj.buildSet = function (mappedEntity) {\r\n\tif (Object.keys(mappedEntity).length === 0) { //TODO hacky\r\n\t\t//C don't make any change\r\n\t\t//! this does have to reference a column that always exists (id)\r\n\t\treturn '\"id\" = \"id\"';\r\n\t} else {\r\n\t\tlet pairs = [];\r\n\t\t//C pair as formatted string\r\n\t\tpairs = Object.keys(mappedEntity).map(key => {\r\n\t\t\tlet input = sj.isType(mappedEntity[key], Array) ? [mappedEntity[key]] : mappedEntity[key];\r\n\t\t\treturn pgp.as.format(`\"${key}\" = $1`, input);\r\n\t\t});\r\n\t\t//C join with ', '\r\n\t\treturn pairs.join(', ');\r\n\t}\r\n};\r\n\r\n\r\n//       \r\n//    \r\n//        \r\n//       \r\n//   \r\n//       \r\n\r\n// CRUD\r\nsj.session.login = async function (db, ctx, user) {\r\n\t//C validate\r\n\tuser.name = await sj.User.schema.name.rule.check(user.name).then(sj.content);\r\n\tuser.password = await sj.User.schema.password.rule.check(user.password).then(sj.content); //! this will error on stuff like 'password must be over x characters long' when really it should just be 'password incorrect', maybe just have a string check rule?\r\n\r\n    //C get password\r\n    let existingPassword = await db.one('SELECT password FROM \"sj\".\"users\" WHERE \"name\" = $1', [user.name]).then(resolved => {\r\n        return resolved.password;\r\n    }).catch(rejected => {\r\n        throw sj.parsePostgresError(rejected, new sj.Error({\r\n            log: false,\r\n            origin: 'login()',\r\n            message: 'could not login, database error',\r\n        }));\r\n    });\r\n\r\n    //C check password\r\n    let isMatch = await bcrypt.compare(user.password, existingPassword).catch(rejected => {\r\n        throw new sj.Error({\r\n            log: true,\r\n            origin: 'login()',\r\n            message: 'server error',\r\n            reason: 'hash compare failed',\r\n            content: rejected,\r\n            target: 'loginPassword',\r\n            cssClass: 'inputError',\r\n        });\r\n    });\r\n    if (!isMatch) {\r\n        throw new sj.Error({\r\n            log: true,\r\n            origin: 'login()',\r\n            message: 'incorrect password',\r\n            target: 'loginPassword',\r\n            cssClass: 'inputError',\r\n        });\r\n    }\r\n\r\n    //C get user\r\n    user = await db.one('SELECT * FROM \"sj\".\"users_self\" WHERE \"name\" = $1', user.name).catch(rejected => {\r\n        throw sj.parsePostgresError(rejected, new sj.Error({\r\n            log: false,\r\n            origin: 'login()',\r\n            message: 'could not login, database error',\r\n        }));\r\n    });\r\n\r\n    ctx.session.user = new sj.User(user);\r\n    return new sj.Success({\r\n        origin: 'login()',\r\n        message: 'user logged in',\r\n        content: ctx.session.user,\r\n    });\r\n};\r\nsj.session.get = async function (ctx) {\r\n    await sj.isLoggedIn(ctx);\r\n    return new sj.Success({\r\n        origin: 'getMe()',\r\n        content: ctx.session.user,\r\n    });\r\n};\r\nsj.session.logout = async function (ctx) {\r\n    delete ctx.session.user;\r\n    return new sj.Success({\r\n        origin: 'logout()',\r\n        message: 'user logged out',\r\n    });\r\n};\r\n\r\n// UTIL\r\nsj.isLoggedIn = async function (ctx) {\r\n    if (!sj.isType(ctx.session.user, sj.User) || !sj.isType(ctx.session.user.id, 'integer')) {\r\n        throw new sj.Error({\r\n            log: true,\r\n            origin: 'isLoggedIn()',\r\n            code: 403,\r\n        \r\n            message: 'you must be logged in to do this',\r\n            reason: 'user is not logged in',\r\n            target: 'notify',\r\n            cssClass: 'notifyError', // TODO consider denial error rather than error error (you messed up vs I messed up)\r\n        });\r\n    }\r\n\t//C redundancy check to make sure id is right format\r\n\tawait sj.Rule.id.check(ctx.session.user.id);\r\n\r\n    //TODO this doesn't check if the user exists however, though wouldn't this be expensive? searching the database everytime the user wants to know if they're logged in, (every page)\r\n\r\n    return new sj.Success({\r\n        origin: 'isLoggedIn()',\r\n        message: 'user is logged in',\r\n    });\r\n};\r\n\r\n\r\n//          \r\n//       \r\n//            \r\n//            \r\n//    \r\n//      \r\n\r\nsj.Entity.augmentClass({\r\n\tprototypeProperties: parent => ({\r\n\t\tasync add(db) {\r\n\t\t\treturn await this.constructor.add(this, db);\r\n\t\t},\r\n\t\tasync get(db) {\r\n\t\t\treturn await this.constructor.get(this, db);\r\n\t\t},\r\n\t\tasync edit(db) {\r\n\t\t\treturn await this.constructor.edit(this, db);\r\n\t\t},\r\n\t\tasync remove(db) {\r\n\t\t\treturn await this.constructor.remove(this, db);\r\n\t\t},\r\n\t}),\r\n\tstaticProperties(parent) {\r\n\t\t// CRUD METHODS\r\n\t\tthis.add = async function (query, db = sj.db) {\r\n\t\t\treturn await this.frame(db, query, 'add');\r\n\t\t};\r\n\t\tthis.get = async function (query, db = sj.db) {\r\n\t\t\treturn await this.frame(db, query, 'get');\r\n\t\t};\r\n\t\tthis.edit = async function (query, db = sj.db) {\r\n\t\t\treturn await this.frame(db, query, 'edit');\r\n\t\t};\r\n\t\tthis.remove = async function (query, db = sj.db) {\r\n\t\t\treturn await this.frame(db, query, 'remove');\r\n\t\t};\r\n\t\tthis.getMimic = async function (query, db = sj.db) {\r\n\t\t\t//C getMimic runs a query through the main database function to be formatted the exact same as any result from a get query, the difference is that it doesn't execute any SQL and returns the data that would be set off in sj.liveData.notify()\r\n\t\t\treturn await this.frame(db, query, 'getMimic');\r\n\t\t};\r\n\r\n\r\n\t\t// FRAME\r\n\t\tthis.frame = async function (db, anyEntities, methodName) {\r\n\t\t\t//C catch sj.Entity\r\n\t\t\tif (this === sj.Entity) throw new sj.Error({\r\n\t\t\t\torigin: 'sj.Entity.[CRUD]',\r\n\t\t\t\treason: `cannot call CRUD method directly on sj.Entity`,\r\n\t\t\t});\r\n\r\n\t\t\t//C cast as array\r\n\t\t\tconst entities = sj.any(anyEntities);\r\n\r\n\t\t\t//C shorthand\r\n\t\t\tconst isGetMimic = methodName === 'getMimic'; //C store getMimic\r\n\t\t\tif (isGetMimic) methodName = 'get'; //C 'getMimic' === 'get' for functions: [methodName+'Function']\r\n\t\t\tconst isGet = methodName === 'get';\r\n\r\n\t\t\tconst accessory = {};\r\n\t\t\t\r\n\r\n\t\t\tconst after = await db.tx(async t => {\r\n\t\t\t\t//C process\r\n\t\t\t\tconst beforeEntities = await this[methodName+'Before'](t, entities, accessory);\r\n\r\n\t\t\t\t//C validate\r\n\t\t\t\tconst validatedEntities = await sj.asyncForEach(beforeEntities, async entity => await this.validate(entity, methodName).catch(sj.propagate));\r\n\r\n\t\t\t\t//C prepare\r\n\t\t\t\tconst preparedEntities = await sj.asyncForEach(validatedEntities, async entity => await this[methodName+'Prepare'](t, entity, accessory).catch(sj.propagate));\r\n\r\n\t\t\t\t//C accommodate\r\n\t\t\t\tconst influencedEntities = !isGet ? await this[methodName+'Accommodate'](t, preparedEntities, accessory).catch(sj.propagate) : [];\r\n\r\n\t\t\t\t//C map\r\n\t\t\t\tconst inputMapped = this.mapColumns(preparedEntities);\r\n\t\t\t\tconst influencedMapped = !isGet ? this.mapColumns(influencedEntities) : [];\r\n\r\n\r\n\t\t\t\t//C execute SQL for inputs\r\n\t\t\t\tconst inputBefore = [];\r\n\t\t\t\tconst inputAfter = isGetMimic ? inputMapped : [];\r\n\t\t\t\tif (!isGetMimic) {\r\n\t\t\t\t\tawait sj.asyncForEach(inputMapped, async entity => {\r\n\t\t\t\t\t\t//C before, ignore add\r\n\t\t\t\t\t\tif (!isGet && methodName !== 'add') {\r\n\t\t\t\t\t\t\tconst before = await this.getQuery(t, sj.shake(entity, this.filters.id)).then(sj.any).catch(sj.propagate)\r\n\t\t\t\t\t\t\tinputBefore.push(...before);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//C after, ignore remove (still needs to execute though)\r\n\t\t\t\t\t\tconst after = await this[methodName+'Query'](t, entity).then(sj.any).catch(sj.propagate);\r\n\t\t\t\t\t\tif (methodName !== 'remove') inputAfter.push(...after);\r\n\t\t\t\t\t}).catch(rejected => {\r\n\t\t\t\t\t\tthrow sj.propagate(new sj.ErrorList({\r\n\t\t\t\t\t\t\t...this[methodName+'Error'](),\r\n\t\t\t\t\t\t\tcontent: rejected,\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//C execute SQL for influenced\r\n\t\t\t\tconst influencedBefore = [];\r\n\t\t\t\tconst influencedAfter = [];\r\n\t\t\t\tif (!isGet) {\r\n\t\t\t\t\tawait sj.asyncForEach(influencedMapped, async influencedEntity => {\r\n\t\t\t\t\t\tconst before = await this.getQuery(t, sj.shake(influencedEntity, this.filters.id)).then(sj.any).catch(sj.propagate);\r\n\t\t\t\t\t\tinfluencedBefore.push(...before);\r\n\r\n\t\t\t\t\t\tconst after = await this.editQuery(t, influencedEntity).then(sj.any).catch(sj.propagate);\r\n\t\t\t\t\t\tinfluencedAfter.push(...after);\r\n\t\t\t\t\t}).catch(rejected => {\r\n\t\t\t\t\t\tthrow sj.propagate(new sj.ErrorList({\r\n\t\t\t\t\t\t\t...this[methodName+'Error'](),\r\n\t\t\t\t\t\t\tcontent: rejected,\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t//C group for iteration\r\n\t\t\t\tconst all = [inputBefore, inputAfter, influencedBefore, influencedAfter];\r\n\r\n\t\t\t\t//C unmap\r\n\t\t\t\tconst unmapped = all.map(list => this.unmapColumns(list));\r\n\r\n\t\t\t\t//C process\r\n\t\t\t\treturn await sj.asyncForEach(unmapped, async list => await this[methodName+'After'](t, list, accessory).catch(sj.propagate));\r\n\t\t\t}).catch(sj.propagate); //! finish the transaction here so that notify won't be called before the database has updated\r\n\r\n\t\t\t//C shake for subscriptions with getOut filter\r\n\t\t\tconst shookGet = after.map(list => sj.shake(list, this.filters.getOut));\r\n\r\n\t\t\t//C timestamp, used for ignoring duplicate notifications in the case of before and after edits, and overlapping queries\r\n\t\t\tconst timestamp = Date.now();\r\n\r\n\t\t\t//C if get, don't notify\r\n\t\t\tif (!isGet) shookGet.forEach(list => sj.liveData.notify(this, list, timestamp, methodName));\r\n\t\t\t//C if getMimic, return shookGet-after\r\n\t\t\telse if (isGetMimic) return shookGet[1]; \r\n\r\n\t\t\t//C shake for return\r\n\t\t\tconst shook = after.map(list => sj.shake(list, this.filters[methodName+'Out']));\r\n\r\n\t\t\t//C rebuild\r\n\t\t\tconst built = shook.map(list => list.map(entity => new this(entity)));\r\n\r\n\t\t\treturn new sj.SuccessList({\r\n\t\t\t\t...this[methodName+'Success'](),\r\n\t\t\t\t//R content is the inputAfter, for removals this will be an empty array, if in the future some 'undo' functionality is needed consider: returned data should still be filtered by removeOut, and therefore might destroy data if this returned data is used to restore it\r\n\t\t\t\tcontent: built[1], \r\n\t\t\t\ttimestamp,\r\n\t\t\t});\r\n\t\t};\r\n\r\n\r\n\t\t// FRAME PARTS\r\n\t\t//G all of these parts are dependant on each other (eg. accessory), so it is ok to make assumptions between these functions\r\n\r\n\t\t//C processes all before validation\r\n\t\tthis.addBefore = \r\n\t\tthis.getBefore = \r\n\t\tthis.editBefore = \r\n\t\tthis.removeBefore = async function (t, entities, accessory) {\r\n\t\t\treturn entities.slice();\r\n\t\t};\r\n\r\n\t\t//C validates each using sj.Entity.schema\r\n\t\tthis.validate = async function (entity, methodName) {\r\n\t\t\tconst validated = {};\r\n\t\t\tawait sj.asyncForEach(Object.keys(this.schema), async key => {\r\n\t\t\t\tconst prop = this.schema[key];\r\n\r\n\t\t\t\t//C catches\r\n\t\t\t\tif (!(prop.rule instanceof sj.Rule)) { // sj.Rule\r\n\t\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\t\tlog: true,\r\n\t\t\t\t\t\torigin: 'sj.Entity.validate()',\r\n\t\t\t\t\t\tmessage: 'validation error',\r\n\t\t\t\t\t\treason: `${key}'s rule is not an sj.Rule`,\r\n\t\t\t\t\t\tcontent: prop,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//C check if optional and not empty, or if required\r\n\t\t\t\tif ((prop[methodName].check && !sj.isEmpty(entity[key])) || prop[methodName].check === 2) {\r\n\t\t\t\t\t//G the against property can be specified in the schema and then assigned to the entity[againstName] before validation\r\n\t\t\t\t\tconst checked = await prop.rule.check(entity[key], entity[prop.against]);\r\n\t\t\t\t\tvalidated[key] = sj.content(checked);\r\n\t\t\t\t\treturn checked;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t//C don't pack into validated\r\n\t\t\t\t\treturn new sj.Success({\r\n\t\t\t\t\t\torigin: 'sj.Entity.validate()',\r\n\t\t\t\t\t\tmessage: `optional ${key} is empty, skipped validation`,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}).catch(rejected => {\r\n\t\t\t\tthrow new sj.ErrorList({\r\n\t\t\t\t\torigin: 'sj.Entity.validate()',\r\n\t\t\t\t\tmessage: 'one or more issues with properties',\r\n\t\t\t\t\treason: 'validating properties returned one or more errors',\r\n\t\t\t\t\tcontent: rejected,\r\n\t\t\t\t});\r\n\t\t\t});\r\n\r\n\t\t\treturn validated;\r\n\t\t};\r\n\r\n\t\t//C modifies each after validation\r\n\t\tthis.addPrepare =\r\n\t\tthis.getPrepare =\r\n\t\tthis.editPrepare = \r\n\t\tthis.removePrepare = async function (t, entity, accessory) {\r\n\t\t\treturn Object.assign({}, entity);\r\n\t\t}\r\n\r\n\t\t//C modifies input entities, returns other influenced entities. checks validated entities against each other and the database to avoid property collisions, calculates the changes required to accommodate the input entities\r\n\t\tthis.addAccommodate =\r\n\t\tthis.getAccommodate =\r\n\t\tthis.editAccommodate =\r\n\t\tthis.removeAccommodate = async function (t, entities, accessory) {\r\n\t\t\treturn [];\r\n\t\t};\r\n\r\n\t\t//C maps js property names to database column names\r\n\t\tthis.mapColumns = function (entities) {\r\n\t\t\t//C switches entities' js named keys for column named keys based on schema\r\n\t\t\treturn entities.map(entity => { //C for each entity\r\n\t\t\t\tlet mappedEntity = {};\r\n\t\t\t\tObject.keys(entity).forEach(key => { //C for each property\r\n\t\t\t\t\tif (sj.isType(this.schema[key], Object) && sj.isType(this.schema[key].columnName, String)) { //C if schema has property \r\n\t\t\t\t\t\tmappedEntity[this.schema[key].columnName] = entity[key]; //C set mappedEntity[columnName] as property value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn(`sj.Entity.mapColumns() - property ${key} in entity not found in schema`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn mappedEntity;\r\n\t\t\t});\r\n\t\t};\r\n\t\tthis.unmapColumns = function (mappedEntities) {\r\n\t\t\t//C inverse of mapColumns()\r\n\t\t\treturn mappedEntities.map(mappedEntity => { //C for each entity\r\n\t\t\t\tlet entity = {};\r\n\t\t\t\tObject.keys(mappedEntity).forEach(columnName => { //C for each columnName\r\n\t\t\t\t\tlet key = Object.keys(this.schema).find(key => this.schema[key].columnName === columnName); //C find key in schema with same columnName\r\n\t\t\t\t\tif (sj.isType(key, String)) {\r\n\t\t\t\t\t\t//C set entity[key] as value of mappedEntity[columnName]\r\n\t\t\t\t\t\tentity[key] = mappedEntity[columnName];\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn(`sj.Entity.unmapColumns() - column ${columnName} in mappedEntity not found in schema`);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\treturn entity;\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t//! this should be overwritten with different ORDER BY columns\r\n\t\tthis.queryOrder = `ORDER BY \"id\" ASC`; \r\n\r\n\t\t//C executes SQL queries\r\n\t\tthis.addQuery = async function (t, mappedEntity) {\r\n\t\t\tlet values = sj.buildValues(mappedEntity);\r\n\r\n\t\t\t//? is returning * still needed when a final SELECT will be called? //TODO also remember to shake off undesired columns, like passwords\r\n\t\t\t//L use where clause as raw: https://github.com/vitaly-t/pg-promise#raw-text\r\n\t\t\tlet row = await t.one(`\r\n\t\t\t\tINSERT INTO \"sj\".\"${this.table}\" \r\n\t\t\t\t$1:raw \r\n\t\t\t\tRETURNING *\r\n\t\t\t`, [values]).catch(rejected => { \r\n\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\tlog: false,\r\n\t\t\t\t\torigin: `sj.${this.name}.add()`,\r\n\t\t\t\t\tmessage: `could not add ${this.name}s`,\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\r\n\t\t\treturn row;\r\n\t\t};\r\n\t\tthis.getQuery = async function (t, mappedEntity) {\r\n\t\t\tlet where = sj.buildWhere(mappedEntity);\r\n\r\n\t\t\tlet rows = await t.any(`\r\n\t\t\t\tSELECT * \r\n\t\t\t\tFROM \"sj\".\"${this.table}\" \r\n\t\t\t\tWHERE $1:raw\r\n\t\t\t\t${this.queryOrder}\r\n\t\t\t`, [where]).catch(rejected => {\r\n\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\tlog: false,\r\n\t\t\t\t\torigin: `sj.${this.name}.get()`,\r\n\t\t\t\t\tmessage: `could not get ${this.name}s`,\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\r\n\t\t\treturn rows;\r\n\t\t};\r\n\t\tthis.editQuery = async function (t, mappedEntity) {\r\n\t\t\tlet {id, ...mappedEntitySet} = mappedEntity;\r\n\t\t\tlet set = sj.buildSet(mappedEntitySet);\r\n\t\t\tlet where = sj.buildWhere({id});\r\n\r\n\t\t\tlet row = await t.one(`\r\n\t\t\t\tUPDATE \"sj\".\"${this.table}\" \r\n\t\t\t\tSET $1:raw \r\n\t\t\t\tWHERE $2:raw \r\n\t\t\t\tRETURNING *\r\n\t\t\t`, [set, where]).catch(rejected => {\r\n\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\tlog: false,\r\n\t\t\t\t\torigin: `sj.${this.name}.edit()`,\r\n\t\t\t\t\tmessage: `could not edit ${this.names}`,\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\r\n\t\t\treturn row;\r\n\t\t};\r\n\t\tthis.removeQuery = async function (t, mappedEntity) {\r\n\t\t\tlet where = sj.buildWhere(mappedEntity);\r\n\r\n\t\t\tlet row = await t.one(`\r\n\t\t\t\tDELETE FROM \"sj\".\"${this.table}\" \r\n\t\t\t\tWHERE $1:raw \r\n\t\t\t\tRETURNING *\r\n\t\t\t`, where).catch(rejected => {\r\n\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\tlog: false,\r\n\t\t\t\t\torigin: `sj.${this.name}.remove()`,\r\n\t\t\t\t\tmessage: `could not remove ${this.names}s`,\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn row;\r\n\t\t};\r\n\r\n\t\t//C processes all after execution\r\n\t\tthis.addAfter = \r\n\t\tthis.getAfter = \r\n\t\tthis.editAfter = \r\n\t\tthis.removeAfter = async function (t, entities, accessory) {\r\n\t\t\treturn entities.slice();\r\n\t\t};\r\n\r\n\t\t//C custom SuccessList and ErrorList\r\n\t\tthis.addSuccess = function () { return {\r\n\t\t\torigin: `sj.${this.name}.add()`,\r\n\t\t\tmessage: `added ${this.name}s`,\r\n\t\t}};\r\n\t\tthis.getSuccess = function () { return {\r\n\t\t\torigin: `sj.${this.name}.get()`,\r\n\t\t\tmessage: `retrieved ${this.name}s`,\r\n\t\t}};\r\n\t\tthis.editSuccess = function () { return {\r\n\t\t\torigin: `sj.${this.name}.edit()`,\r\n\t\t\tmessage: `edited ${this.name}s`,\r\n\t\t}};\r\n\t\tthis.removeSuccess = function () { return {\r\n\t\t\torigin: `sj.${this.name}.get()`,\r\n\t\t\tmessage: `removed ${this.name}s`,\r\n\t\t}};\r\n\r\n\t\tthis.addError = function () { return {\r\n\t\t\torigin: `sj.${this.name}.add()`,\r\n\t\t\tmessage: `failed to add ${this.name}s`,\r\n\t\t}};\r\n\t\tthis.getError = function () { return {\r\n\t\t\torigin: `sj.${this.name}.get()`,\r\n\t\t\tmessage: `failed to retrieve ${this.name}s`,\r\n\t\t}};\r\n\t\tthis.editError = function () { return {\r\n\t\t\torigin: `sj.${this.name}.edit()`,\r\n\t\t\tmessage: `failed to edit ${this.name}s`,\r\n\t\t}};\r\n\t\tthis.removeError = function () { return {\r\n\t\t\torigin: `sj.${this.name}.remove()`,\r\n\t\t\tmessage: `failed to remove ${this.name}s`,\r\n\t\t}};\r\n\t},\r\n});\r\n\r\nsj.Source.augmentClass({\r\n\tconstructorProperties: parent => ({\r\n\t\tdefaults: {\r\n\t\t\tserverTestProp: null,\r\n\t\t},\r\n\t}),\r\n});\r\n\r\n//      \r\n//     \r\n//       \r\n//       \r\n//    \r\n//       \r\n\r\nsj.User.augmentClass({\r\n\tstaticProperties(parent) {\r\n\t\t// CRUD\r\n\t\tthis.addPrepare = \r\n\t\tthis.editPrepare = async function (t, user) {\r\n\t\t\tlet newUser = Object.assign([], user);\r\n\t\r\n\t\t\t//C hash password\r\n\t\t\t//TODO might be a vulnerability here with this string check\r\n\t\t\tif (sj.isType(newUser.password, String)) newUser.password = await bcrypt.hash(newUser.password, saltRounds).catch(rejected => {\r\n\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\tlog: true,\r\n\t\t\t\t\torigin: 'sj.User.add()',\r\n\t\t\t\t\tmessage: 'failed to add user',\r\n\t\t\t\t\treason: 'hash failed',\r\n\t\t\t\t\tcontent: rejected,\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\r\n\t\t\treturn newUser;\r\n\t\t};\r\n\t\r\n\t\tthis.queryOrder = 'ORDER BY \"id\" ASC';\r\n\t},\r\n});\r\n\r\n\r\n//                  \r\n//             \r\n//                    \r\n//                       \r\n//                     \r\n//                      \r\n\r\nsj.Playlist.augmentClass({\r\n\tstaticProperties: parent => ({\r\n\t\t// CRUD\r\n\t\tqueryOrder: 'ORDER BY \"userId\" ASC, \"id\" ASC',\r\n\t}),\r\n});\r\n\r\n\r\n//        \r\n//   \r\n//              \r\n//              \r\n//              \r\n//                \r\n\r\nsj.Track.augmentClass({\r\n\tprototypeProperties(parent) {\r\n\t\tthis.order = async function (db = sj.db) {\r\n\t\t\treturn await this.constructor.order(db, sj.any(this));\r\n\t\t};\r\n\t},\r\n\tstaticProperties(parent) {\r\n\t\t// CRUD\r\n\t\tthis.addBefore = \r\n\t\tthis.getBefore = \r\n\t\tthis.editBefore = \r\n\t\tthis.removeBefore = async function (t, entities) {\r\n\t\t\tlet newEntities = entities.slice();\r\n\t\t\tnewEntities.forEach(entity => {\r\n\t\t\t\tentity.source = sj.isType(entity.source, Object) && sj.isType(entity.source.name, String)\r\n\t\t\t\t? entity.source.name\r\n\t\t\t\t: undefined;\r\n\t\t\t});\r\n\t\t\treturn newEntities;\r\n\t\t};\r\n\t\r\n\t\tthis.addPrepare = async function (t, track) {\r\n\t\t\t//C set id of tracks to be added as a temporary symbol, so that sj.Track.order() is able to identify tracks\r\n\t\t\tlet newTrack = {...track, id: Symbol()};\r\n\t\t\tif (!sj.isType(newTrack.position, 'integer')) {\r\n\t\t\t\tlet existingTracks = await sj.Track.get({playlistId: newTrack.playlistId}, t).then(sj.content);\r\n\t\t\t\tnewTrack.position = existingTracks.length;\r\n\t\t\t}\r\n\t\t\treturn newTrack;\r\n\t\t};\r\n\t\tthis.removePrepare = async function (t, track) {\r\n\t\t\t//C set position of tracks to be removed as null, so that sj.Track.order() recognizes them as tracks to remove\r\n\t\t\treturn {...track, position: null};\r\n\t\t};\r\n\t\r\n\t\tthis.queryOrder = 'ORDER BY \"playlistId\" ASC, \"position\" ASC';\r\n\t\r\n\t\tthis.addAccommodate = \r\n\t\tthis.editAccommodate =\r\n\t\tthis.removeAccommodate = async function (t, tracks) {\r\n\t\t\t//L pg-promise transactions https://github.com/vitaly-t/pg-promise#transactions\r\n\t\t\t//L deferrable constraints  https://www.postgresql.org/docs/9.1/static/sql-set-constraints.html\r\n\t\t\t//L https://stackoverflow.com/questions/2679854/postgresql-disabling-constraints\r\n\t\t\tawait t.none(`SET CONSTRAINTS \"sj\".\"tracks_playlistId_position_key\" DEFERRED`).catch(rejected => {\r\n\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\tlog: false,\r\n\t\t\t\t\torigin: 'sj.Track.move()',\r\n\t\t\t\t\tmessage: 'could not order tracks, database error',\r\n\t\t\t\t\ttarget: 'notify',\r\n\t\t\t\t\tcssClass: 'notifyError',\r\n\t\t\t\t}));\r\n\t\t\t});\r\n\t\t\treturn await this.order(t, tracks).then(sj.content).catch(sj.propagate);\r\n\t\t};\r\n\t\r\n\t\tthis.addAfter =\r\n\t\tthis.getAfter =\r\n\t\tthis.editAfter = \r\n\t\tthis.deleteAfter = async function (t, entities) {\r\n\t\t\tlet newEntities = entities.slice();\r\n\r\n\t\t\tnewEntities.forEach(entity => {\r\n\t\t\t\tentity.source = sj.Source.instances.find(source => source.name === entity.source);\r\n\t\t\t});\r\n\t\t\t\r\n\t\t\treturn newEntities;\r\n\t\t};\r\n\r\n\t\t// UTIL\r\n\t\tthis.order = async function (db, tracks) {\r\n\t\t\t//C takes a list of input tracks for an INSERT, UPDATE, or DELETE query\r\n\t\t\t//! properties should be validated at this point\r\n\t\t\t//! tracks to be added must have a Symbol() id, this will be removed\r\n\t\t\t//! tracks to be deleted must have a null position, this will be removed\r\n\t\r\n\t\t\t//C modifies the input track's positions, if needed\r\n\t\t\t//C returns a list of influenced tracks with modified positions, if needed\r\n\t\r\n\t\t\t//C out-of-bounds positions will be repositioned at the start or end of the playlist\r\n\t\t\t//C duplicate positions will be repositioned in order of input order\r\n\t\t\t//C in the case of repositioned tracks that still overlap with other input tracks, all will be repositioned in order of input position\r\n\t\t\t\r\n\t\r\n\t\t\t//C filter out tracks\r\n\t\t\tlet inputTracks = tracks.filter(track => \r\n\t\t\t\t//C without an id (including symbol)\r\n\t\t\t\t(!sj.isEmpty(track.id) || typeof track.id === 'symbol') \r\n\t\t\t\t//C and without a position (including null) or playlistId\r\n\t\t\t\t&& (!sj.isEmpty(track.position) || track.position === null || !sj.isEmpty(track.playlistId))); \r\n\t\t\t//C filter out duplicate tracks (by id, keeping last), by filtering for tracks where every track after does not have the same id\r\n\t\t\tinputTracks = inputTracks.filter((track, index, self) => self.slice(index+1).every(trackAfter => track.id !== trackAfter.id));\r\n\t\r\n\t\t\t//C return early if none are moving\r\n\t\t\tif (inputTracks.length === 0) {\r\n\t\t\t\treturn new sj.SuccessList({\r\n\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\tmessage: 'track positions did not need to be set',\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log('inputTracks.length:', inputTracks.length, '\\n ---');\r\n\t\r\n\t\t\treturn await db.tx(async t => {\r\n\t\t\t\tconst playlists = [];\r\n\t\t\t\tconst influencedTracks = [];\r\n\t\t\t\tconst inputIndex = Symbol();\r\n\t\r\n\t\t\t\t//C retrieve track's playlist, group each track by playlist & moveType\r\n\t\t\t\tawait sj.asyncForEach(inputTracks, async (track, index) => {\r\n\t\t\t\t\tconst storePlaylist = function (playlistId, existingTracks) {\r\n\t\t\t\t\t\tif (!sj.isType(playlistId, 'integer')) throw new sj.Error({\r\n\t\t\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\t\t\treason: `playlistId is not an integer: ${playlistId}`,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tif (!Array.isArray(existingTracks)) throw new sj.Error({\r\n\t\t\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\t\t\treason: `existingTracks is not an array: ${existingTracks}`,\r\n\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\t//C stores playlist in playlists if not already stored\r\n\t\t\t\t\t\tlet existingPlaylist = playlists.find(playlist => playlist.id === playlistId);\r\n\t\t\t\t\t\tif (!existingPlaylist) {\r\n\t\t\t\t\t\t\tplaylists.push({\r\n\t\t\t\t\t\t\t\tid: playlistId,\r\n\t\t\r\n\t\t\t\t\t\t\t\toriginal: existingTracks,\r\n\t\t\r\n\t\t\t\t\t\t\t\t//C move actions, these have priority positioning\r\n\t\t\t\t\t\t\t\tinputsToMove: [],\r\n\t\t\t\t\t\t\t\tinputsToAdd: [], \r\n\t\t\t\t\t\t\t\tinputsToRemove: [],\r\n\t\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\t\texistingPlaylist = playlists[playlists.length-1];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn existingPlaylist;\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\t//C temporarily store inputIndex on track, this is required as the input order is lost when tracks are grouped by playlist\r\n\t\t\t\t\ttrack[inputIndex] = index;\r\n\t\r\n\t\t\t\t\t//C determine move action\r\n\t\t\t\t\tconst action =\r\n\t\t\t\t\ttypeof track.id === 'symbol' \t? 'Add' \t:\r\n\t\t\t\t\ttrack.position === null \t\t? 'Remove' \t: 'Move';\r\n\t\r\n\t\r\n\t\t\t\t\t//C get current playlist by playlistId if action === 'add', else by track.id using a sub-query\r\n\t\t\t\t\t//L sub-query = vs IN: https://stackoverflow.com/questions/13741582/differences-between-equal-sign-and-in-with-subquery\r\n\t\t\t\t\tconst currentQuery = action === 'Add' \r\n\t\t\t\t\t? pgp.as.format(`\r\n\t\t\t\t\t\tSELECT \"id\", \"position\", \"playlistId\"\r\n\t\t\t\t\t\tFROM \"sj\".\"tracks\" \r\n\t\t\t\t\t\tWHERE \"playlistId\" = $1\r\n\t\t\t\t\t`, track.playlistId)\r\n\t\t\t\t\t: pgp.as.format(`\r\n\t\t\t\t\t\tSELECT \"id\", \"position\", \"playlistId\"\r\n\t\t\t\t\t\tFROM \"sj\".\"tracks\" \r\n\t\t\t\t\t\tWHERE \"playlistId\" = (\r\n\t\t\t\t\t\t\tSELECT \"playlistId\"\r\n\t\t\t\t\t\t\tFROM \"sj\".\"tracks\"\r\n\t\t\t\t\t\t\tWHERE \"id\" = $1\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t`, track.id);\r\n\t\t\t\t\tconst currentPlaylist = await t.any('$1:raw', currentQuery).catch(rejected => {\r\n\t\t\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\t\t\tlog: false,\r\n\t\t\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\t\t\tmessage: 'could not move tracks',\r\n\t\t\t\t\t\t}));\r\n\t\t\t\t\t});\r\n\t\r\n\t\r\n\t\t\t\t\t//C store\r\n\t\t\t\t\tconst currentPlaylistStored = storePlaylist(action === 'Add' ? track.playlistId : currentPlaylist[0].playlistId, currentPlaylist); //! track.playlistId might not be currentPlaylistId\r\n\t\t\t\t\t//C strip playlistId from playlist, this is done so that only modified properties will remain on the track objects\r\n\t\t\t\t\tcurrentPlaylistStored.original.forEach(t => {\r\n\t\t\t\t\t\tdelete t.playlistId;\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (!sj.isType(track.playlistId, 'integer') || track.playlistId === currentPlaylistStored.id) { \r\n\t\t\t\t\t\t//C if not switching playlists\r\n\t\t\t\t\t\t//C group by action\r\n\t\t\t\t\t\tcurrentPlaylistStored['inputsTo'+action].push(track);\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\t//C if switching playlists\r\n\t\t\t\t\t\t//C this should catch tracks with playlistIds but no position\r\n\t\t\t\t\t\tconst anotherPlaylist = await t.any(`\r\n\t\t\t\t\t\t\tSELECT \"id\", \"position\", \"playlistId\"\r\n\t\t\t\t\t\t\tFROM \"sj\".\"tracks\" \r\n\t\t\t\t\t\t\tWHERE \"playlistId\" = $1\r\n\t\t\t\t\t\t`, track.playlistId).catch(rejected => {\r\n\t\t\t\t\t\t\tthrow sj.parsePostgresError(rejected, new sj.Error({\r\n\t\t\t\t\t\t\t\tlog: false,\r\n\t\t\t\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\t\t\t\tmessage: 'could not move tracks',\r\n\t\t\t\t\t\t\t}));\r\n\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\tconst anotherPlaylistStored = storePlaylist(track.playlistId, anotherPlaylist);\r\n\t\t\t\t\t\tanotherPlaylistStored.original.forEach(t => {\r\n\t\t\t\t\t\t\tdelete t.playlistId;\r\n\t\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t\t//C track is removed from its current playlist, and added to another playlist\r\n\t\t\t\t\t\tcurrentPlaylistStored.inputsToRemove.push(track);\r\n\t\t\t\t\t\tanotherPlaylistStored.inputsToAdd.push(track);\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn new sj.Success({\r\n\t\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\t\tmessage: \"retrieved track's playlist\",\r\n\t\t\t\t\t});\r\n\t\t\t\t}).catch(rejected => {\r\n\t\t\t\t\tthrow new sj.ErrorList({\r\n\t\t\t\t\t\torigin: 'sj.Track.order() - movingTracks iterator',\r\n\t\t\t\t\t\tmessage: `could not retrieve some track's playlist`,\r\n\t\t\t\t\t\tcontent: rejected,\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\t\r\n\t\t\t\t//console.log('playlists.length:', playlists.length, '\\n ---');\r\n\t\r\n\t\t\t\t//C calculate new track positions required to accommodate input tracks' positions\r\n\t\t\t\tplaylists.forEach(playlist => {\r\n\t\t\t\t\t//C populate others with tracks in original that are not in inputsTo Add, Remove, or Move\r\n\t\t\t\t\t//! inputsToRemove can be ignored from this point on, these tracks aren't included in others and wont be added to the final ordered list\r\n\t\t\t\t\tplaylist.others = playlist.original.filter(originalTrack => \r\n\t\t\t\t\t\t!playlist.inputsToAdd.some(addingTrack => addingTrack.id === originalTrack.id) &&\r\n\t\t\t\t\t\t!playlist.inputsToRemove.some(trackToRemove => trackToRemove.id === originalTrack.id) &&\r\n\t\t\t\t\t\t!playlist.inputsToMove.some(movingTrack => movingTrack.id === originalTrack.id)\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t//console.log('playlist.others.length:', playlist.others.length);\r\n\t\r\n\t\t\t\t\t//C combine both adding and moving, \r\n\t\t\t\t\tplaylist.inputsToPosition = [...playlist.inputsToAdd, ...playlist.inputsToMove];\r\n\t\t\t\t\t//C give tracks with no position an Infinite position so they get added to the bottom of the playlist\r\n\t\t\t\t\tplaylist.inputsToPosition.forEach(trackToPosition => {\r\n\t\t\t\t\t\tif (!sj.isType(trackToPosition.position, Number)) {\r\n\t\t\t\t\t\t\ttrackToPosition.position === Infinity;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\r\n\t\r\n\t\t\t\t\t//C sort\r\n\t\t\t\t\tsj.stableSort(playlist.others, (a, b) => a.position - b.position);\r\n\t\t\t\t\t//C stable sort by inputIndex then position to resolve clashes by position then inputIndex\r\n\t\t\t\t\tsj.stableSort(playlist.inputsToPosition, (a, b) => a[inputIndex] - b[inputIndex]);\r\n\t\t\t\t\tsj.stableSort(playlist.inputsToPosition, (a, b) => a.position - b.position);\r\n\t\r\n\t\t\t\t\t//console.log('playlist.inputsToAdd.length:', playlist.inputsToAdd.length);\r\n\t\t\t\t\t//console.log('playlist.inputsToRemove.length:', playlist.inputsToRemove.length);\r\n\t\t\t\t\t//console.log('playlist.inputsToMove.length:', playlist.inputsToMove.length, '\\n ---');\r\n\t\t\t\t\t//console.log('playlist.inputsToPosition.length:', playlist.inputsToPosition.length, '\\n ---');\r\n\t\t\t\t\t\r\n\t\r\n\t\t\t\t\t//C inputIndex is no longer needed, remove it from anything it was added to\r\n\t\t\t\t\tplaylist.inputsToPosition.forEach(trackToPosition => {\r\n\t\t\t\t\t\tdelete trackToPosition[inputIndex];\r\n\t\t\t\t\t});\r\n\t\t\t\t\tplaylist.inputsToRemove.forEach(trackToRemove => {\r\n\t\t\t\t\t\tdelete trackToRemove[inputIndex];\r\n\t\t\t\t\t});\r\n\t\r\n\t\r\n\t\t\t\t\t//C populate merged by filling others tracks around combined tracks\r\n\t\t\t\t\tplaylist.merged = [];\r\n\t\t\t\t\t//! these are copies that will be emptied below\r\n\t\t\t\t\tplaylist.inputsToPositionCopy = [...playlist.inputsToPosition];\r\n\t\t\t\t\tplaylist.othersCopy = [...playlist.others];\r\n\t\t\t\t\tlet i = 0;\r\n\t\t\t\t\twhile (playlist.othersCopy.length > 0) {\r\n\t\t\t\t\t\tif (playlist.inputsToPositionCopy.length > 0 && playlist.inputsToPositionCopy[0].position <= i) {\r\n\t\t\t\t\t\t\t//C if the next adding or moving track's position is at (or before, in the case of a duplicated position) the current index, transfer it to the merged list\r\n\t\t\t\t\t\t\t//C this will properly handle negative and duplicate positions\r\n\t\t\t\t\t\t\t//G shift removes the first item of an array and returns that item\r\n\t\t\t\t\t\t\tplaylist.merged.push(playlist.inputsToPositionCopy.shift());\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t//C else - transfer the next others track\r\n\t\t\t\t\t\t\tplaylist.merged.push(playlist.othersCopy.shift());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ti++;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//C push rest of combined tracks\r\n\t\t\t\t\t//R this method was chosen over including combined.length > 0 in the while condition to prevent needless loops caused by ridiculously high positions, this was also chosen over original.length because adding + moving tracks could be greater the playlist length\r\n\t\t\t\t\t//L .push() and spread: https://stackoverflow.com/questions/1374126/how-to-extend-an-existing-javascript-array-with-another-array-without-creating\r\n\t\t\t\t\tplaylist.merged.push(...playlist.inputsToPositionCopy);\r\n\t\t\t\t\tplaylist.inputsToPositionCopy.length = 0; //! remove combined tracks for consistent behavior\r\n\t\r\n\t\r\n\t\t\t\t\t//C populate playlist.influenced with all non-input tracks that have moved\r\n\t\t\t\t\tplaylist.influenced = playlist.merged.filter((mergedTrack, index) => {\r\n\t\t\t\t\t\tlet inOthers = playlist.others.find(otherTrack => otherTrack.id === mergedTrack.id);\r\n\t\t\t\t\t\tlet influenced = inOthers && index !== inOthers.position;\r\n\t\r\n\t\t\t\t\t\t//C assign new positions (inputTracks too)\r\n\t\t\t\t\t\tmergedTrack.position = index;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\treturn influenced;\r\n\t\t\t\t\t});\r\n\t\r\n\t\t\t\t\t//console.log('playlist.merged.length:', playlist.merged.length);\r\n\t\t\t\t\t//console.log('playlist.merged:\\n', playlist.merged, '\\n ---');\r\n\t\r\n\t\t\t\t\t//console.log('playlist.influenced.length:', playlist.influenced.length);\r\n\t\t\t\t\t//console.log('playlist.influenced:\\n', playlist.influenced, '\\n ---');\r\n\t\r\n\t\t\t\t\tinfluencedTracks.push(...playlist.influenced);\r\n\t\t\t\t});\r\n\t\r\n\t\t\t\t//C remove temporary symbol id from add tracks and null position from delete tracks\r\n\t\t\t\tinputTracks.forEach(inputTrack => {\r\n\t\t\t\t\tif (typeof inputTrack.id === 'symbol') {\r\n\t\t\t\t\t\tdelete inputTrack.id;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (inputTrack.position === null) {\r\n\t\t\t\t\t\tdelete inputTrack.position;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\r\n\t\t\t\treturn new sj.SuccessList({\r\n\t\t\t\t\torigin: 'sj.Track.order()',\r\n\t\t\t\t\tmessage: 'influenced tracks calculated',\r\n\t\t\t\t\tcontent: influencedTracks,\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\r\n\t\t\t/* Thought Process\r\n\t\r\n\t\t\t\tif any tracks have position set,\r\n\t\t\t\t\tdo the move function\r\n\t\t\t\t\torder\r\n\t\t\t\tafter deleting tracks\r\n\t\t\t\t\torder\r\n\t\t\r\n\t\t\t\tidea: get the tracklist, then do the moving and ordering outside, at the same time - then update all at once\r\n\t\t\t\tthe fetched array won't have holes in it, just the position numbers (which is good?)\r\n\t\t\r\n\t\t\t\t//R initial idea wrong: \r\n\t\t\t\ttracks must be in order of their positions for the move to be applied properly (ie tracks with positions: 3, 4, 5 will all be inserted inbetween tracks 2 and 3) - updating in the order 5, 4, 3 would result in later tracks pushing the already placed tracks down (so their positions end up being 7, 5, 3)\r\n\t\t\t\tit needs to go in decending order because of the nature of how the move function works - affecting only tracks below it\r\n\t\t\r\n\t\t\r\n\t\t\t\t//R wrong, because this done simultaneously (not in sequence) it will separate adjacent inserted positions (0i, 1i) will insert into a full list (o) as (0i, 0o, 1i, 1o), doing this in sequence would require reordering (updating of new positions) the tracks after each insert (might be resource intensive)\r\n\t\t\t\tget input\r\n\t\t\t\t\tstable sort by position\r\n\t\t\t\tget tracks\r\n\t\t\t\t\tstable sort by position\r\n\t\t\t\t\tprepend item with position -Infinity\r\n\t\t\t\t\tappend item with position Infinity\r\n\t\t\r\n\t\t\t\tfor each input (in reverse order, so that inputs with same positions do not get their order reversed)\r\n\t\t\t\t\tfind where position is greater than i.position and less than or equal to i+1.position\r\n\t\t\t\t\tsplice(i+1, 0, input)\r\n\t\t\t\t\r\n\t\t\r\n\t\t\t\tfinal idea: \r\n\t\t\t\t\tget the existing list, remove tracks to be inserted\r\n\t\t\t\t\tsort each list\r\n\t\t\t\t\tfor the length of the combined lists, for integers 0 to length\r\n\t\t\t\t\t\tif there is a track in the input list at (or less than) the index - push the next one\r\n\t\t\t\t\t\telse push the next track in the existing list\r\n\t\t\t\t\tif there are any remaining tracks in the input list (for example a big hole that makes the last few tracks larger than the sum of both lists), push them in order to the end of the list\r\n\t\t\t\t\tlastly do a order to remove duplicates and holes\r\n\t\t\r\n\t\t\t\t\tthis essentially 'fills' the existing tracks around the set positions of the input tracks\r\n\t\r\n\t\r\n\t\t\t\t\tfor sj.Track.order()\r\n\t\t\t\t\t\tthere is a recursive loop hazard in here (basically if sj.Track.get() is the function that calls sj.Track.order() - sj.Track.order() itself needs to call sj.Track.get(), therefore a loop), however if everything BUT sj.Track.get() calls sj.Track.order(), then sj.Track.order() can safely call sj.Track.get(), no, the same thing happens with sj.Track.edit() - so just include manual queries, no have it so: sj.Track.get() doesn't use either moveTracks() or orderTracks(), these two methods are then free to use sj.Track.get(), and then have each use their own manual update queries - basically add, edit, remove can use these and sj.Track.get() but not each other - this is written down in that paper chart\r\n\t\r\n\t\r\n\t\t\t\t\t//R moveTracks() cannot be done before INSERT (as in editTracks()) because the tracks don't exist yet, and the input tracks do not have their own id properties yet. the result tracks of the INSERT operation cannot be used for moveTracks() as they only have their current positions, so the result ids and input positions need to be combined for use in moveTracks(), but we don't want to position tracks don't have a custom position (1 to reduce cost, 2 to maintain the behavior of being added to the end of the list (if say n later tracks are positioned ahead of m former tracks, those m former tracks will end up being n positions from the end - not at the very end). so:\r\n\t\r\n\t\t\t\t\t//C for tracks with a custom position, give the input tracks their result ids and the result tracks their custom positions\r\n\t\t\t\t\t//! requires the INSERT command to be executed one at at a time for each input track\r\n\t\t\t\t\t//R there is no way to pair input tracks with their output rows based on data because tracks have no unique properties (aside from the automatically assigned id), but because the INSERT statements are executed one at a time, the returned array is guaranteed to be in the same order as the input array, therefore we can use this to pair tracks\r\n\t\t\t*/\r\n\t\t};\r\n\t},\t\r\n});\r\n\r\n\r\nexport default sj;","//      \r\n//   \r\n//             \r\n//            \r\n//        \r\n//           \r\n\r\n/*\r\n\t//L process.env: https://www.twilio.com/blog/2017/08/working-with-environment-variables-in-node-js.html\r\n\t//L dotenv:  https://www.npmjs.com/package/dotenv\r\n*/\r\n\r\n\r\n//       \r\n//  \r\n//                \r\n//                \r\n//        \r\n//             \r\n\r\n/* \r\n\tPut api keys into .env after creating methods to access them\r\n\tSome best practices: https://www.codementor.io/mattgoldspink/nodejs-best-practices-du1086jja\r\n\tMiddleware best practices https://github.com/koajs/koa/blob/master/docs/guide.md\r\n\r\n\terrors thrown in some places (like routes) still aren't caught\r\n*/\r\n\r\n\r\n//            \r\n//      \r\n//                     \r\n//                    \r\n//         \r\n//              \r\n\r\n// top\r\nimport '../config/config.mjs';\r\n\r\n// builtin\r\nimport path from 'path';\r\n\r\n// external\r\nimport parser from 'minimist';\r\nimport Koa from 'koa'; //L https://github.com/koajs\r\nimport koaWebpack from 'koa-webpack';\r\nimport bodyParser from 'koa-bodyparser'; //L https://github.com/koajs/bodyparser\r\nimport session from 'koa-session'; //L https://github.com/koajs/session\r\n\r\n//L https://github.com/socketio/socket.io#in-conjunction-with-koa\r\nimport SocketIO from 'socket.io'; //L socket io: https://socket.io/docs/emit-cheatsheet\r\nimport http from 'http'; //TODO consider changing to the https module?\r\n\r\n// internal\r\nimport sourcePath from '../source-path.cjs';\r\nimport { clientOptions, clientIndexFileName } from '../config/webpack.config.mjs';\r\nimport sj from './global-server.mjs';\r\nimport Router from './routes.mjs';\r\n\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//          \r\n\r\n// OPTIONS\r\nconst serverOptions = parser(process.argv.slice(2), {\r\n\tstring: [\r\n\t\t'client',\r\n\t\t'client-mode',\r\n\t],\r\n\tdefault: {\r\n\t\t/* Options\r\n\t\t\t'off'      - assume code is already built/watched by another process\r\n\t\t\t'compile'  - builds the client code once\r\n\t\t\t'watch'    - watches the client code\r\n\t\t\t'refresh'  - use webpack-dev-middleware\r\n\t\t\t'hot'      - use webpack HMR\r\n\t\t*/\r\n\t\t'client': 'off',\r\n\t\t/* Options\r\n\t\t\t'development' - passed to webpack\r\n\t\t\t'production'  - passed to webpack\r\n\t\t*/\r\n\t\t'client-mode': 'development',\r\n\t},\r\n});\r\n\r\n// INTERPRET\r\nconst useMiddleware = (serverOptions.client === 'refresh' || serverOptions.client === 'hot');\r\n\r\n// const compiler = webpack(client({}, {\r\n// \tmode: serverOptions['client-mode'],\r\n// }));\r\n// compiler.run((error, stats) => {\r\n// \tif (error) {\r\n// \t\tconsole.error(error);\r\n// \t\treturn;\r\n// \t}\r\n\r\n// \tconsole.log(stats.toString({\r\n// \t\tcolors: true,\r\n// \t}));\r\n// });\r\n\r\n\r\n(async function () {\r\n\r\nconst config = clientOptions({}, {\r\n\tmode: serverOptions['client-mode'],\r\n});\r\n\r\nlet koaWebpackMiddleware;\r\nconst routerOptions = {};\r\nif (useMiddleware) {\r\n\tkoaWebpackMiddleware = await koaWebpack({\r\n\t\t// compiler: compiler,\r\n\t\tconfig,\r\n\t\tdevMiddleware: {\r\n\t\t\tmethods: ['HEAD', 'GET', 'POST', 'PATCH', 'DELETE'],\r\n\t\t},\r\n\t\thotClient: false,\r\n\t});\r\n\r\n\trouterOptions.replaceIndex = function (ctx) {\r\n\t\tconst filename = path.resolve(config.output.path, clientIndexFileName);\r\n\t\tctx.response.type = 'html';\r\n\t\tctx.response.body = koaWebpackMiddleware.devMiddleware.fileSystem.createReadStream(filename);\r\n\t};\r\n}\r\nconst router = Router(routerOptions);\r\n\r\n\r\n\r\n\r\nconst PORT = process.env.PORT || 3000;\r\n\r\n// KOA\r\nconst app = new Koa();\r\napp.keys = [process.env.APP_KEY || 'imJustSomeKey'];\r\nconst sessionConfig = {\r\n\t//TODO random keys: //L https://randomkeygen.com/\r\n\r\n\t//C (string)(default is koa:sess) cookie key\r\n\tkey: 'koa:sess', \r\n\t//C (number || 'session')(default is 1 days) maxAge in ms, 'session' will result in a cookie that expires when session/browser is closed, Warning: If a session cookie is stolen, this cookie will never expire\r\n\tmaxAge: 86400000, \r\n\t//C (boolean)(default true) can overwrite or not\r\n\toverwrite: true,\r\n\t//C (boolean)(default true) httpOnly or not , httpOnly cookies tell the browser not to expose them to client-side script (so that they can only be opened by the server)\r\n\thttpOnly: true,\r\n\t//C (boolean)(default true) signed or not , signed cookies verify that the data is unchanged on the client side\r\n\tsigned: true,\r\n\t//C (boolean)(default false) Force a session identifier cookie to be set on every response. The expiration is reset to the original maxAge, resetting the expiration countdown. , I think this means that the session is reset after every request? (that is that the maxAge is basically since the last time the user made a request)\r\n\trolling: true,\r\n\t//C (boolean)(default is false) renew session when session is nearly expired, so we can always keep user logged in, //? does this mean never expiring sessions?\r\n\trenew: false, \r\n};\r\n\r\n//L https://github.com/socketio/socket.io#in-conjunction-with-koa\r\nconst server = http.createServer(app.callback());\r\n\r\n// SOCKET IO\r\nconst socketIO = new SocketIO(server);\r\nsj.liveData.socket = socketIO.of('/live-data');\r\n\r\n\r\n//                   \r\n//            \r\n//                 \r\n//               \r\n//        \r\n//               \r\n\r\n/*\r\n\t// response timer\r\n\tapp.use(async (ctx, next) => {\r\n\t\tconst start = Date.now();\r\n\t\tawait next();\r\n\t\tconst ms = Date.now() - start;\r\n\t\tctx.response.set('response-time', `${ms}ms`);\r\n\t});\r\n\r\n\t// request logger\r\n\tapp.use(async (ctx, next) => {\r\n\t\tconsole.log(`${ctx.request.method} ${ctx.request.path}`);\r\n\t\tawait next();\r\n\t});\r\n*/\r\n\r\n// BODY PARSER\r\napp.use(bodyParser());\r\n\r\n// SESSION\r\napp.use(session(sessionConfig, app));\r\n\r\n/*\r\n\t// view counter\r\n\tapp.use(async (ctx, next) => {\r\n\t\t// ignore favicon\r\n\t\t// TODO this doesn't work as it's processing two 'requests' per view - the page and it's resources\r\n\t\tif (ctx.request.path !== '/favicon.ico') {\r\n\t\t\tlet n = ctx.session.views || 0;\r\n\t\t\tctx.session.views = ++n;\r\n\t\t} \r\n\t\t//console.log(ctx.session.views + ' views');\r\n\t\tawait next();\r\n\t});\r\n*/\r\n\r\nif (useMiddleware) {\r\n\tapp.use(koaWebpackMiddleware);\r\n}\r\n\r\n\r\n// ROUTES\r\napp.use(router.routes());\r\n\r\n//L https://github.com/alexmingoia/koa-router#routerallowedmethodsoptions--function\r\napp.use(router.allowedMethods()); \r\n\r\n\r\n// LIVE DATA\r\nsj.liveData.start({\r\n\tapp,\r\n\tsocket: socketIO.of('/live-data'),\r\n});\r\n\r\n\r\n//          \r\n//         \r\n//                \r\n//               \r\n//         \r\n//          \r\n\r\n// START SERVER\r\n//G Connect at http://localhost:<PORT>\r\nserver.listen(PORT, () => {\r\n\tconsole.log(`\\n`);\r\n\tconsole.log(`SERVER LISTENING ON PORT ${PORT}`);\r\n});\r\n\r\n//L unhandled errors: https://stackoverflow.com/questions/43834559/how-to-find-which-promises-are-unhandled-in-node-js-unhandledpromiserejectionwar\r\nprocess.on('unhandledRejection', (reason, p) => {\r\n    console.log('Unhandled Rejection at:', p, '\\n Reason:', reason);\r\n    //TODO handle\r\n});\r\n\r\n\r\n})();","//            \r\n//      \r\n//                     \r\n//                    \r\n//         \r\n//              \r\n\r\n// EXTERNAL\r\nimport http from 'http'; //TODO consider changing to the https module?\r\n\r\n// INTERNAL\r\n//! depends on the common global.mjs not the global-server.mjs because global-server.mjs uses this module\r\nimport sj from '../public/js/global.mjs';\r\n\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//          \r\n\r\n//TODO there is a stack overflow error here somewhere, recursive loop?, usually lead by this error: 'no subscriber found for this user'\r\n// when refreshing the playlist page, all the lists will subscribe fine, until at some point unsubscribe is called (for an empty query [ {} ] , or maybe could be anything) upon which no subscriber is called, and the thing goes to a 'RangeError: Maximum call stack size exceeded' error\r\n\r\n//TODO this may be unrelated but it seems the liveQueries here are also piling up\r\n\r\nsj.Subscription.augmentClass({\r\n\tconstructorParts: parent => ({\r\n\t\tdefaults: {\r\n\t\t\tuser: null,\r\n\t\t},\r\n\t}),\r\n});\r\n\r\nexport default {\r\n\tapp: null,\r\n\tsocket: null,\r\n\ttables: sj.LiveTable.makeTables(),\r\n\r\n\tstart({\r\n\t\tapp,\r\n\t\tsocket,\r\n\t}) {\r\n\t\tthis.app = app;\r\n\t\tthis.socket = socket;\r\n\r\n\t\tthis.socket.use((socket, next) => {\r\n\t\t\t//C give the cookie session to the socket\r\n\t\t\t//C uses a temporary koa context to decrypt the session\r\n\t\t\t//L https://medium.com/@albertogasparin/sharing-koa-session-with-socket-io-8d36ac877bc2\r\n\t\t\t//L https://github.com/koajs/session/issues/53#issuecomment-311601304\r\n\t\t\t//!//? socket.session is static, whereas koa ctx.session is dynamic, that is I'm not sure that this is linked in any way to the cookie session\r\n\t\t\t//L https://socket.io/docs/server-api/#namespace-use-fn\r\n\t\t\tsocket.session = this.app.createContext(socket.request, new http.OutgoingMessage()).session;\r\n\t\t\tnext();\r\n\t\t});\r\n\r\n\t\tthis.socket.on('connect', (socket) => {\r\n\t\t\tconsole.log('CONNECT', socket.id);\r\n\t\t\t\r\n\t\t\t//C if user is logged in, give the socketId to the session\r\n\t\t\t//! I don't think the cookie session receives this, though it isn't needed there so far\r\n\t\t\tif (sj.isType(socket.session.user, sj.User)) socket.session.user.socketId = socket.id;\r\n\r\n\t\t\tsocket.on('disconnect', async (reason) => {\r\n\t\t\t\tconsole.log('DISCONNECT', socket.id);\r\n\r\n\t\t\t\tawait sj.liveData.disconnect(socket.id).catch(rejected => { \r\n\t\t\t\t\t//TODO handle better\r\n\t\t\t\t\tif (sj.isType(rejected, sj.Base)) rejected.announce();\r\n\t\t\t\t\telse console.error('subscription disconnect error:', rejected);\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\t//? socket won't be used anymore, so does anything really need to be deleted here?\r\n\t\t\t\tif (sj.isType(socket.session.user, sj.User)) socket.session.user.socketId = sj.User.defaults.socketId;\r\n\t\t\t});\r\n\r\n\t\t\tsocket.on('subscribe', async ({table, query}, callback) => {\r\n\t\t\t\tconsole.log('SUBSCRIBE', socket.id);\r\n\r\n\t\t\t\t//C if user is not logged in, create an empty user with just it's socketId (this is how subscribers are identified)\r\n\t\t\t\t//TODO socketId validator, this is all that really matters here\r\n\t\t\t\tconst user = sj.isType(socket.session.user, sj.User)\r\n\t\t\t\t\t? socket.session.user\r\n\t\t\t\t\t: new sj.User({socketId: socket.id});\r\n\t\t\t\t\t\r\n\t\t\t\t//! using sj.Entity.tableToEntity(table) instead of just a table string so that the function can basically function as a validator\r\n\t\t\t\tconst result = await sj.liveData.add(sj.Entity.tableToEntity(table), query, user).catch(sj.andResolve);\r\n\r\n\t\t\t\t//!//G do not send back circular data in the acknowledgment callback, SocketIO will cause a stack overflow\r\n\t\t\t\t//L https://www.reddit.com/r/node/comments/8diy81/what_is_rangeerror_maximum_call_stack_size/dxnkpf7?utm_source=share&utm_medium=web2x\r\n\t\t\t\t//C using sj.deepClone (fClone) to drop circular references\r\n\t\t\t\tcallback(sj.deepClone(result));\t\t\r\n\t\t\t});\r\n\t\t\tsocket.on('unsubscribe', async ({table, query}, callback) => {\r\n\t\t\t\tconsole.log('UNSUBSCRIBE', socket.id);\r\n\r\n\t\t\t\tconst user = sj.isType(socket.session.user, sj.User)\r\n\t\t\t\t\t? socket.session.user\r\n\t\t\t\t\t: new sj.User({socketId: socket.id});\r\n\r\n\t\t\t\tconst result = await sj.liveData.remove(sj.Entity.tableToEntity(table), query, user).catch(sj.andResolve);\r\n\t\t\t\tcallback(sj.deepClone(result));\r\n\t\t\t});\r\n\r\n\t\t\tsocket.on('error', (reason) => {\r\n\t\t\t\tconsole.error('ERROR', socket.id, reason);\r\n\t\t\t});\r\n\t\t});\r\n\t},\r\n\r\n\tfindTable(Entity) {\r\n\t\treturn this.tables.get(Entity);\r\n\t},\r\n\tfindLiveQuery(table, query) {\r\n\t\treturn table.liveQueries.find(liveQuery => sj.deepMatch(query, liveQuery.query, {matchOrder: false}));\r\n\t},\r\n\tfindSubscription(liveQuery, user) {\r\n\t\treturn liveQuery.subscriptions.find(subscription => subscription.user.socketId === user.socketId);\r\n\t},\r\n\t\r\n\t//C subscribers/users are identified by their socketId, this is so that not-logged-in clients can still subscribe to data, while still allowing the full user object to be the subscriber\r\n\tasync add(Entity, query, user) {\r\n\t\t//C process query\r\n\t\t//TODO//? getMimic was being called with this query: [{playlistId: null}], twice, very rapidly, however even though they are the same query, the one called second resolves before the first one, why? afaik this isn't causing any issues, but it could later\r\n\t\tconst processedQuery = await Entity.getMimic(query);\r\n\r\n\t\t//C find table\r\n\t\tconst table = this.findTable(Entity);\r\n\t\tif (!sj.isType(table, sj.LiveTable)) throw new sj.Error({\r\n\t\t\torigin: 'sj.liveData.add()',\r\n\t\t\treason: 'table is not an sj.LiveTable',\r\n\t\t});\r\n\r\n\t\t//C find liveQuery, add if it doesn't exist\r\n\t\tlet liveQuery = this.findLiveQuery(table, processedQuery);\r\n\t\tif (!sj.isType(liveQuery, sj.LiveQuery)) {\r\n\t\t\tliveQuery = new sj.LiveQuery({\r\n\t\t\t\ttable,\r\n\t\t\t\tquery: processedQuery,\r\n\t\t\t});\r\n\t\t\tthis.findTable(Entity).liveQueries.push(liveQuery);\r\n\t\t}\r\n\r\n\t\t//C find subscription, add if it doesn't exist\r\n\t\tlet subscription = this.findSubscription(liveQuery, user);\r\n\t\tif (!sj.isType(subscription, sj.Subscription)) {\r\n\t\t\tsubscription = new sj.Subscription({\r\n\t\t\t\tliveQuery,\r\n\t\t\t\tuser,\r\n\t\t\t});\r\n\t\t\tliveQuery.subscriptions.push(subscription);\r\n\t\t}\r\n\r\n\t\t//C update user\r\n\t\tObject.assign(subscription.user, user);\r\n\r\n\t\treturn new sj.Success({\r\n\t\t\torigin: 'sj.addSubscriber()',\r\n\t\t\tmessage: 'added subscriber',\r\n\t\t\tcontent: processedQuery,\r\n\t\t});\r\n\t},\r\n\tasync remove(Entity, query, user) {\r\n\t\t//? if the client unsubscribes on the client-side but is unable to unsubscribe on the server-side, the subscription will sit there (and send messages) until the client disconnects, is this ok? maybe consider a timeout system?\r\n\r\n\t\t//C process query\r\n\t\tconst processedQuery = await Entity.getMimic(query);\r\n\t\t\r\n\t\t//C find table\r\n\t\tconst table = this.findTable(Entity);\r\n\t\tif (!sj.isType(table, sj.LiveTable)) throw new sj.Error({\r\n\t\t\torigin: 'sj.liveData.remove()',\r\n\t\t\treason: 'table is not an sj.LiveTable',\r\n\t\t});\r\n\r\n\t\t//C find liveQuery index\r\n\t\tconst liveQuery = this.findLiveQuery(table, processedQuery);\r\n\t\tconst liveQueryIndex = this.findTable(Entity).liveQueries.indexOf(liveQuery);\r\n\t\tif (!sj.isType(liveQuery, sj.LiveQuery) || liveQueryIndex < 0) return new sj.Warn({\r\n\t\t\torigin: 'sj.subscriptions.remove()',\r\n\t\t\tmessage: 'no subscription found for this query',\r\n\t\t\tcontent: {\r\n\t\t\t\tEntity,\r\n\t\t\t\tquery: processedQuery,\r\n\t\t\t\tliveQueryIndex,\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\t//C find subscription\r\n\t\tconst subscription = this.findSubscription(liveQuery, user);\r\n\t\tconst subscriptionIndex = liveQuery.subscriptions.indexOf(subscription);\r\n\t\tif (!sj.isType(subscription, sj.Subscription) || subscriptionIndex < 0) return new sj.Warn({\r\n\t\t\torigin: 'sj.subscriptions.remove()',\r\n\t\t\tmessage: 'no subscriber found for this user',\r\n\t\t\tcontent: {\r\n\t\t\t\tliveQuerySubscriptions: liveQuery.subscriptions,\r\n\t\t\t\tsocketId: user.socketId,\r\n\t\t\t\tsubscriptionIndex,\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\t//C remove subscription\r\n\t\tliveQuery.subscriptions.splice(subscriptionIndex, 1);\r\n\r\n\t\t//C if no more subscriptions, remove liveQuery\r\n\t\tif (liveQuery.subscriptions.length <= 0) {\r\n\t\t\tthis.findTable(Entity).liveQueries.splice(liveQueryIndex, 1);\r\n\t\t}\r\n\t\r\n\t\treturn new sj.Success({\r\n\t\t\torigin: 'sj.removeSubscriber()',\r\n\t\t\tmessage: 'removed subscriber',\r\n\t\t\tcontent: processedQuery,\r\n\t\t});\r\n\t},\r\n\r\n\tasync notify(Entity, entities, timestamp) {\r\n\t\t//C for each liveQuery\r\n\t\tconst table = this.findTable(Entity);\r\n\t\tif (!sj.isType(table, sj.LiveTable)) throw new sj.Error({\r\n\t\t\torigin: 'sj.liveData.notify()',\r\n\t\t\treason: 'table is not an sj.LiveTable',\r\n\t\t});\r\n\r\n\t\tfor (const liveQuery of table.liveQueries) {\r\n\t\t\t//C for each passed entity\r\n\t\t\tfor (const entity of entities) {\r\n\t\t\t\t//C if any part of the liveQuery.query matches the entity as a subset && if the notification timestamp is new\r\n\t\t\t\t//R query is an array of object queries, must iterate each then subset match, or else nothing will match because query switches from superset to subset\r\n\t\t\t\tif (\r\n\t\t\t\t\tliveQuery.query.some(part => sj.deepMatch(part, entity, {\r\n\t\t\t\t\t\tmatchOrder: false,\r\n\t\t\t\t\t\tmatchIfSubset: true,\r\n\t\t\t\t\t\tmatchIfTooDeep: true,\r\n\t\t\t\t\t})) &&\r\n\t\t\t\t\ttimestamp > liveQuery.timestamp\r\n\t\t\t\t) {\r\n\t\t\t\t\t//C set the new timestamp\r\n\t\t\t\t\tliveQuery.timestamp = timestamp;\r\n\r\n\t\t\t\t\t//C for each subscription\r\n\t\t\t\t\tfor (const subscription of liveQuery.subscriptions) {\r\n\t\t\t\t\t\t//C emit a socket notification to the subscriber\r\n\t\t\t\t\t\tthis.socket.to(subscription.user.socketId).emit('notify', {\r\n\t\t\t\t\t\t\ttable: Entity.table,\r\n\t\t\t\t\t\t\tquery: liveQuery.query,\r\n\t\t\t\t\t\t\ttimestamp,\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\tasync disconnect(socketId) {\r\n\t\t//? unsubscribe all on disconnect and resubscribe all on connect? or have a timeout system?\r\n\t\t//! this doesn't use the remove() method, because the specific subscription (query + user) aren't known, this finds all subscriptions with that user\r\n\r\n\t\tfor (const pair of this.tables) {\r\n\t\t\tconst table = pair[1];\r\n\t\t\tfor (let i = table.liveQueries.length-1; i > -1; i--) {\r\n\t\t\t\tconst liveQuery = table.liveQueries[i];\r\n\t\t\t\t//C for each subscription\r\n\t\t\t\tfor (let j = liveQuery.subscriptions.length-1; j > -1; j--) {\r\n\t\t\t\t\tconst subscription = liveQuery.subscriptions[j];\r\n\t\t\t\t\t//C if it matches the passed user (by socketId), remove it\r\n\t\t\t\t\tif (subscription.user.socketId === socketId) {\r\n\t\t\t\t\t\tliveQuery.subscriptions.splice(j, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//C if the liveQuery no longer has any subscriptions, remove it\r\n\t\t\t\tif (liveQuery.subscriptions.length <= 0) table.liveQueries.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n};\r\n\r\n/* //TODO test:\r\n\tno duplicate live queries\r\n\tsubscriptions get removed on disconnect\r\n\tsingle refreshed liveQuery only ever has one subscription (user)\r\n*/\r\n","//      \r\n//   \r\n//             \r\n//            \r\n//        \r\n//           \r\n\r\n/*\r\n\t//G\r\n\tnon-idempotent: (different result depending on how many times called)\r\n\tPOST\t\t-\tCreate\r\n\r\n\tidempotent: (same result no matter how many times called)\r\n\tGET\t\t-\tRetrieve\r\n\tPUT\t\t-\tUpdate (replace entirely)\r\n\tPATCH\t-\tUpdate (partially)\r\n\tDELETE\t-\tDelete\r\n\r\n\t//L put vs post: https://stackoverflow.com/questions/630453/put-vs-post-in-rest\r\n\r\n\t//G only use await next(); inside a route when the request should be further processed down the chain (ie. to finally result at .all), I cant think of a reason why this would be wanted (just use more middleware instead to do this)\r\n\r\n\t//L \r\n\tpath parameters vs query parameters: https://stackoverflow.com/questions/3198492/rest-standard-path-parameters-or-request-parameters\r\n\tuse path parameters to retrieve a specific item (via unique identifier)\r\n\tuse query parameters to retrieve a list of items (via 'query parameters')\r\n\t/:type/:id \tare accessed via ctx.params.x\r\n\t/type?id=123\tare accessed via ctx.query.x\r\n\thttps://github.com/alexmingoia/koa-router#url-parameters\r\n\r\n\r\n\t//G all methods (except get) should pass parameters as their respective sj.Base \r\n\t//G get uses name as the identifier, TODO but should also accept id in the future\r\n\r\n\tnode module.exports (unused, switched to ES Modules)\r\n\t//L https://medium.freecodecamp.org/node-js-module-exports-vs-exports-ec7e254d63ac\r\n\texports is a reference to module.exports. therefore - ok to assign properties to both, ok to do module.exports= but not exports=\r\n\r\n\t//R use query parameters for api get requests where multiple params may be needed or optional, use the single path parameters for page get requests where we're looking for a simple unique route\r\n*/\r\n\r\n\r\n//       \r\n//  \r\n//                \r\n//                \r\n//        \r\n//             \r\n\r\n/*\r\n\tconsider using a separate router for source-api requests (sourceRouter)\r\n\r\n\terror converting sj.Track() to JSON because of circular reference\r\n*/\r\n\r\n\r\n//            \r\n//      \r\n//                     \r\n//                    \r\n//         \r\n//              \r\n\r\n// builtin\r\nimport path from 'path';\r\nimport fs from 'fs';\r\n\r\n// external\r\nimport Router from 'koa-router'; //L https://github.com/alexmingoia/koa-router\r\nimport send from 'koa-send'; //L https://github.com/koajs/send\r\n\r\n// internal\r\nimport sourcePath from '../source-path.cjs';\r\nimport { clientIndexFileName } from '../config/webpack.config.mjs';\r\nimport sj from './global-server.mjs';\r\nimport auth from './auth.mjs'; // side-effects\r\n\r\n\r\n//     \r\n//    \r\n//         \r\n//        \r\n//         \r\n//          \r\n\r\nexport default function ({replaceIndex}) {\r\n\t// path\r\n\t//L make own __dirname since it isn't exposed in modules: https://stackoverflow.com/questions/46745014/alternative-for-dirname-in-node-when-using-the-experimental-modules-flag\r\n\t//L remove 'file:///' because it messes up the parsing and creates 'C:/C:/': https://github.com/tc39/proposal-import-meta/issues/13\r\n\t//TODO there has to be a cleaner way of doing this (especially the replace manipulation)\r\n\t//R this was needed when running raw modules as __dirname was not accessible, however webpack now handles that\r\n\t// const __dirname = path.dirname(new URL(import.meta.url.replace(/^file:\\/\\/\\//, '')).pathname);\r\n\tconst root = sourcePath('../build/public');\r\n\tconst app = `/${clientIndexFileName}`;\r\n\r\n\t// router\r\n\tconst router = new Router();\r\n\tconst apiRouter = new Router();\r\n\r\n\r\n\t//     \r\n\t//  \r\n\t//  \r\n\t//   \r\n\t//         \r\n\t//         \r\n\t//TODO consider putting .catch(sj.andResolve) as a middleware?\r\n\r\n\t/*\r\n\t\tlet listenerList = [\r\n\t\t];\r\n\r\n\t\tasync function addListener(depth) {\r\n\t\t\t//TODO this is a mess, there has to be a much better way to do this\r\n\r\n\t\t\t//C stop recursion if 10 layers deep\r\n\t\t\tdepth = depth || 0;\r\n\t\t\tif (depth >= 10) {\r\n\t\t\t\tthrow new sj.Error({\r\n\t\t\t\t\tlog: true,\r\n\t\t\t\t\torigin: 'addListener()',\r\n\t\t\t\t\tmessage: 'could not handle request, timeout error',\r\n\t\t\t\t\treason: 'addListener timeout',\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tlet f = Math.random();\r\n\r\n\t\t\tif (listeners.indexOf(f) !== -1) {\r\n\t\t\t\tf = await addListener(depth+1); //! recursive call\r\n\t\t\t}\r\n\r\n\t\t\tif (depth === 0) {\r\n\t\t\t\tlisteners.push(f);\r\n\t\t\t}\r\n\r\n\t\t\treturn f;\r\n\t\t}\r\n\t*/\r\n\t// server-side data & processing requests\r\n\tapiRouter\r\n\t.post('/log', async (ctx, next) => {\r\n\t\tconsole.log('CLIENT LOG:', ctx.request.body.message);\r\n\t\tctx.response.body = new sj.Success({\r\n\t\t\torigin: 'routes.mjs /log POST',\r\n\t\t\tmessage: 'received client log message',\r\n\t\t});\r\n\t})\r\n\r\n\t// auth\r\n\t.get('/spotify/authRequestStart', async (ctx, next) => {\r\n\t\t//C retrieves an auth request URL and it's respective local key (for event handling)\r\n\t\tctx.response.body = await sj.spotify.startAuthRequest().catch(sj.andResolve);\r\n\t})\r\n\t.get('/spotify/authRedirect', async (ctx, next) => { \r\n\t\t//C receives credentials sent from spotify, emits an event & payload that can then be sent back to the original client\r\n\t\t//! this URL is sensitive to the url given to spotify developer site (i think)\r\n\t\tawait sj.spotify.receiveAuthRequest(ctx.request.query).catch(sj.andResolve);\r\n\t\tawait send(ctx, app, {root: root});\r\n\t})\r\n\t.post('/spotify/authRequestEnd', async (ctx, next) => {\r\n\t\tctx.response.body = await sj.spotify.endAuthRequest(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.post('/spotify/exchangeToken', async (ctx, next) => {\r\n\t\tctx.response.body = await sj.spotify.exchangeToken(ctx, ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.get('/spotify/refreshToken', async (ctx, next) => {\r\n\t\tctx.response.body = await sj.spotify.refreshToken(ctx).catch(sj.andResolve);\r\n\t})\r\n\r\n\t.get('/youtube/credentials', async (ctx, next) => {\r\n\t\tctx.response.body = await sj.youtube.getCredentials().catch(sj.andResolve);\r\n\t})\r\n\r\n\r\n\t// session\r\n\t//R //L login/logout are create/remove for sessions: https://stackoverflow.com/questions/31089221/what-is-the-difference-between-put-post-and-patch, https://stackoverflow.com/questions/5868786/what-method-should-i-use-for-a-login-authentication-request\r\n\t//? what is the 'update' equivalent of user session? isn't this all done server-side by refreshing the cookie? or is this just the login put because there is no post equivalent instead\r\n\t.post('/session', async (ctx, next) => {\r\n\t\tctx.response.body = await sj.session.login(sj.db, ctx, ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.get('/session', async (ctx, next) => {\r\n\t\t//R thought about moving this to user, but with 'self' permissions, but if its a me request, the user specifically needs to know who they are - in get user cases, the user already knows what they're searching for an just needs the rest of the information\r\n\t\tctx.response.body = await sj.session.get(ctx).catch(sj.andResolve);\r\n\t})\r\n\t.delete('/session', async (ctx, next) => {\r\n\t\tctx.response.body = await sj.session.logout(ctx).catch(sj.andResolve);\r\n\t})\r\n\r\n\r\n\t// user\r\n\t.post(`/${sj.User.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.User.add(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.get(`/${sj.User.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.User.get(sj.decodeList(ctx.querystring)).catch(sj.andResolve);\r\n\t})\r\n\t.patch(`/${sj.User.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.User.edit(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.delete(`/${sj.User.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.User.remove(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\r\n\t// playlist\r\n\t.post(`/${sj.Playlist.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Playlist.add(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.get(`/${sj.Playlist.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Playlist.get(sj.decodeList(ctx.querystring)).catch(sj.andResolve);\r\n\t})\r\n\t.patch(`/${sj.Playlist.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Playlist.edit(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.delete(`/${sj.Playlist.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Playlist.remove(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\r\n\t// track\r\n\t.post(`/${sj.Track.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Track.add(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.get(`/${sj.Track.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Track.get(sj.decodeList(ctx.querystring)).catch(sj.andResolve);\r\n\t})\r\n\t.patch(`/${sj.Track.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Track.edit(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\t.delete(`/${sj.Track.table}`, async (ctx, next) => {\r\n\t\tctx.response.body = await sj.Track.remove(ctx.request.body).catch(sj.andResolve);\r\n\t})\r\n\r\n\t// catch\r\n\t.all('/*', async (ctx, next) => {\r\n\t\tctx.response.body = new sj.Error({\r\n\t\t\tlog: true,\r\n\t\t\torigin: 'apiRouter',\r\n\t\t\tmessage: 'could not process request',\r\n\t\t\treason: 'invalid api command',\r\n\t\t\tcontent: ctx.request.body,\r\n\t\t});\r\n\t});\r\n\r\n\t//L nested routers: https://github.com/alexmingoia/koa-router#nested-routers\r\n\trouter.use('/api', apiRouter.routes(), apiRouter.allowedMethods()); \r\n\r\n\r\n\t//       \r\n\t//   \r\n\t//      \r\n\t//        \r\n\t//         \r\n\t//           \r\n\r\n\trouter\r\n\t.get('/*', async (ctx, next) => {\r\n\t\t/*\r\n\t\t\t//C pages are accessed through the base GET method, serve any public files here\r\n\t\t\t//! static resource references in index.html should be absolute '/foo', not relative './foo'\r\n\r\n\t\t\t//! \"Note: To deploy .mjs on the web, your web server needs to be configured to serve files with this extension using the appropriate Content-Type: text/javascript header\"\r\n\t\t\t//L https://developers.google.com/web/fundamentals/primers/modules\r\n\r\n\t\t\t//TODO //! errors thrown here aren't caught - fix this here and everywhere else\r\n\t\t*/\r\n\r\n\t\t//L temporarily ignore favicon request: https://stackoverflow.com/questions/35408729/express-js-prevent-get-favicon-ico\r\n\t\tif (ctx.request.path === '/favicon.ico') {\r\n\t\t\tctx.response.status = 204;\r\n\t\t\treturn;\r\n\t\t\t//TODO add it and remove this block\r\n\t\t}\r\n\r\n\t\t//C serve resources\r\n\t\tif (fs.existsSync(path.join(root, ctx.request.path)) && ctx.request.path.indexOf('.') >= 0) {\r\n\t\t\tawait send(ctx, ctx.request.path, {root: root});\r\n\t\t\treturn;\r\n\t\t\t//TODO find a better way to differentiate a valid file from a just a valid path (other than indexOf('.'))\r\n\t\t\t//TODO webpack might have a better way to identify static resources\r\n\t\t} \r\n\t\t\r\n\t\t//C redirect if not logged in\r\n\t\tif (sj.isEmpty(ctx.session.user) && ctx.request.path !== '/login' && ctx.request.path !== '/database') { //TODO this should use sj.isLoggedIn, though that isn't perfect yet and it's async\r\n\t\t\tctx.request.path = '/'; //! ctx.redirect() will not redirect if ctx.request.path is anything but '/', no idea why\r\n\t\t\tctx.redirect('/login');\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// if (replaceIndex !== undefined) {\r\n\t\t// \treplaceIndex(ctx);\r\n\t\t// } \r\n\t\t// else {\r\n\t\t\t//C otherwise always return the index.js file, this is the root app and vue will handle the routing client-side\r\n\t\t\t//L https://router.vuejs.org/guide/essentials/history-mode.html#example-server-configurations\r\n\t\t\tawait send(ctx, app, {root: root});\r\n\t\t// }\r\n\t})\r\n\t.all('/*', async (ctx, next) => {\r\n\t\tctx.body = ctx.body + '.all /* reached';\r\n\t\t//G only use\tawait next();\twhen we want the request to be further processed down the chain (ie. to finally result at .all)\r\n\t});\t\r\n\r\n\treturn router;\r\n};\r\n","/* //R Workaround for __dirname / import.meta / webpack issues. \r\n\tThe __dirname node global doesn't exist in ES Modules, even when run with node.\r\n\t\tWebpack is supposed to be able to polyfill this with node: {__dirname: true}, however it doesn't seem to be working.\r\n\tThe alternative import.meta would normally be the workaround for raw modules. \r\n\t\tHowever Webpack doesn't support this yet: //L https://github.com/webpack/webpack/issues/6719\r\n\t\t@open-wc/webpack-import-meta-loader didn't work because it relies on window which isn't available in node.\r\n\t\t@bable/plugin-syntax-import-meta just didn't work at all.\r\n\t\tWhen webpack is able to parse import.meta, this could be a universal solution:\r\n\t\t\t//OLD\r\n\t\t\timport path from 'path';\r\n\r\n\t\t\texport default function (metaURL) {\r\n\t\t\t\treturn path.dirname(new URL(metaURL.replace(/^file:\\/\\/\\//, '')).pathname);\r\n\t\t\t};\r\n\t//! The best solution so far is to only use __dirname in a CommonJS Module, and instead import it into ES Modules.\r\n\t\t//! This still requires using node: {__dirname: true}\r\n\t\t//L Solution from: https://medium.com/@almtechhub/es-modules-and-import-meta-dirname-babel-trick-39aad026682\r\n\tHere its being wrapped in a path call because using the exported __dirname from outside this directory wouldn't make much semantic sense.\r\n*/\r\n//G Use in places where __dirname would normally be required, like config options or non-webpack-recognized imports.\r\n//! Do NOT move this file, unless all references to this function are updated.\r\nconst {resolve} = require('path');\r\nmodule.exports = (...relativePaths) => resolve(__dirname, ...relativePaths);\r\n","module.exports = require(\"bcryptjs\");","module.exports = require(\"clean-webpack-plugin\");","module.exports = require(\"dotenv\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"html-webpack-plugin\");","module.exports = require(\"http\");","module.exports = require(\"koa\");","module.exports = require(\"koa-bodyparser\");","module.exports = require(\"koa-router\");","module.exports = require(\"koa-send\");","module.exports = require(\"koa-session\");","module.exports = require(\"koa-webpack\");","module.exports = require(\"minimist\");","module.exports = require(\"node-fetch\");","module.exports = require(\"path\");","module.exports = require(\"pg-promise\");","module.exports = require(\"socket.io\");","module.exports = require(\"spotify-web-api-node\");","module.exports = require(\"vue-loader/lib/plugin.js\");","module.exports = require(\"webpack\");","module.exports = require(\"webpack-node-externals\");"],"sourceRoot":""}